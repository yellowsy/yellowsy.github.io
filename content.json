{"meta":{"title":"紫薯与你","subtitle":"","description":"","author":"Huang_SY","url":"https://yellowsy.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-09-17T08:22:24.621Z","updated":"2022-09-17T08:22:24.621Z","comments":true,"path":"about/index.html","permalink":"https://yellowsy.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2022-09-12T12:05:35.303Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"https://yellowsy.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-09-15T07:38:06.513Z","updated":"2022-09-15T07:38:06.513Z","comments":true,"path":"links/index.html","permalink":"https://yellowsy.github.io/links/index.html","excerpt":"","text":""},{"title":"catedories","date":"2022-09-08T13:21:18.000Z","updated":"2022-09-08T13:21:18.168Z","comments":true,"path":"catedories/index.html","permalink":"https://yellowsy.github.io/catedories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-15T08:25:12.213Z","updated":"2022-09-15T08:25:12.213Z","comments":true,"path":"tags/index.html","permalink":"https://yellowsy.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-15T08:28:14.837Z","updated":"2022-09-15T08:28:14.837Z","comments":true,"path":"categories/index.html","permalink":"https://yellowsy.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-09-12T12:05:35.303Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://yellowsy.github.io/books/index.html","excerpt":"","text":""},{"title":"search","date":"2022-09-08T13:18:32.000Z","updated":"2022-09-08T13:18:32.223Z","comments":true,"path":"search/index.html","permalink":"https://yellowsy.github.io/search/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-09-12T12:05:35.303Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"https://yellowsy.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"进程的同步互斥和进程间通信","slug":"进程的同步互斥和进程间通信","date":"2022-09-14T16:28:12.000Z","updated":"2022-09-17T04:45:12.012Z","comments":true,"path":"2022/09/15/进程的同步互斥和进程间通信/","link":"","permalink":"https://yellowsy.github.io/2022/09/15/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"一、 引起同步互斥问题的原因同步：因为一些任务不是有一个进程实现，而是通过多个进程共同实现，所以这些进程之间按照一定的规则，互相协调合作共同实现某一任务而进行同步。 互斥：因为在多个程序并发执行时，由于共享系统资源，对于临界资源，多个进程只能进行互斥的访问，即每次只能允许一个进程访问，所以这些进程对于该资源的访问就形成了相互制约的关系。 二、 同步互斥方法说明2.1 互斥锁同步互斥方法说明当多个线程对公共资源进行访问和写入时，加上互斥锁以保证数据不会被多个线程操作时而混乱。下面以简单读，写操作来说明。一个线程从共享的缓冲区中读取操作，另一个线程向缓冲区中写数据，保证不会对共享缓冲区同时读取和写入，对共享缓冲区的访问加上互斥锁实现。通过线程函数pthread_create()在主进程中创建两个线程，一个进行读取，另一个进行写入，如果缓冲区为空，那么就向缓冲区中写入数据，并将buffer_has_sem设置为1，让读线程可以读取数据。读线程则先判断缓冲区是否为空，不为空为输出数据。 2.2 条件变量同步互斥方法说明条件变量是对互斥锁的补充，它的作用是用于多线程之间关于共享数据状态变化的通信，它允许线程阻塞并等待另一个线程发送的信号。当收到信号时，阻塞的线程就被唤醒并试图锁定与之相关的互斥锁。以哲学家就餐例子说明。哲学家拿到左右的两只筷子就可以开始吃饭，吃完饭放下筷子思考，利用互斥锁和条件变量进行同步互斥。因为对筷子数量的访问属于临界资源访问，所以对i号哲学家拿筷子进行上锁，拿完后便开锁。当i号哲学家拿不到左右两只筷子时，便通过条件变量开始等待，其他哲学吃完放下筷子后可以发送信号给该哲学家，当他再次发现筷子可用时便开始吃饭。以通信的方式来实现两者的同步互斥。 2.3 信号量同步互斥方法说明信号量是一个用于表示资源数目的整型量S，它仅能通过两个标准的原子操作wait(S)和signal(S)来访问，它是具有一个等待队列的计数器，属于临界资源的一种，要获取信号量资源，则对信号量进行-1操作，要释放信号量资源，则对信号量资源进行+1操作。以读者写者问题进行说明。读和写操作不能同时进行。允许多个读者同时读取数据，通过设置rw_mutex信号量来实现读写进程的互斥访问，read_cound来统计读者的数量，mutex用于对read_cound同步互斥的访问。一旦一个读者获得了读锁，其他的读者也可以获取这个读锁。但是，想要获取写锁的线程，就必须等到所有的读者都结束。 2.4 屏障同步互斥方法说明 屏障是用户协调多个线程并行工作的同步机制。当线程到达屏障点时，它不能继续，直到所有其他的线程也已经到这一点。当最后的线程到达屏障点时，所有线程被释放，并且能够恢复并发执行。使用pthread_barrier_init()函数对屏障进行初始化，使用count参数指定，在允许所有线程继续运行之前，必须到达屏障的线程数目。使用pthread_barrier_wait()函数来表明，线程已工作完成，准备等所有其他线程赶上来。以选手评分例子说明。在主线程中创建3个子线程，一个求最高分，另一个求最低分，最后一个线程去掉最高分和最低分后求其平均值，该线程在求最后平均分时必须要等到另外两个子线程求出最高分和最低分。求出的最后得分在主线程中输出。 三、 同步互斥方法实现3.1互斥锁同步互斥方法实现3.1.1 互斥锁同步互斥示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#define FALSE 0#define TRUE 1char buffer[256];//定义共享缓冲区int buffer_has_item=0;//判断缓冲区是否有数据int retflag=FALSE;pthread_mutex_t mutex;//定义互斥锁void readfun()&#123; while(1) &#123; if(retflag) return; pthread_mutex_lock(&amp;mutex);//对读操作进行上锁 if(buffer_has_item==1) &#123; printf(&quot;reader：%s\\n&quot;,buffer); buffer_has_item=0; &#125; pthread_mutex_unlock(&amp;mutex);//对读操作进行开锁 &#125;&#125;void writefun()&#123; int i=0; while(1) &#123; if(i==5)//写入5个数据就退出 &#123; retflag=TRUE; return; &#125; pthread_mutex_lock(&amp;mutex);//对写入操作进行上锁 if(buffer_has_item==0) &#123; printf(&quot;writer：%c\\n&quot;,i+’a’); sprintf(buffer,&quot;%c&quot;,i+’a’); buffer_has_item=1; &#125; pthread_mutex_unlock(&amp;mutex);//对写入操作进行开锁 &#125;&#125;int main()&#123; //定义两个线程ID pthread_t reader; pthread_t writer; pthread_mutex_init(&amp;mutex,NULL);//初始化互斥锁 //创建两个子线程 pthread_create(&amp;reader,NULL,(void*)&amp;readfun,NULL); pthread_create(&amp;writer,NULL,(void*)&amp;writefun,NULL); //等待两个子线程结束 pthread_join(reader,NULL); pthread_join(writer,NULL); return 0;&#125; 编译后运行： 运行结果： 3.1.2 互斥锁同步互斥关键代码说明（1）函数说明： ​ pthread_mutex_inti(&amp;mutex,NULL); &#x2F;&#x2F;初始化互斥锁 ​ pthread_mutex_lock(&amp;mutex); &#x2F;&#x2F;上锁 ​ pthread_mutex_unlock(&amp;mutex); &#x2F;&#x2F;开锁 ​ pthread_join(reader,NULL); &#x2F;&#x2F;等待写入线程结束 ​ pthread_join(writer,NULL);&#x2F;&#x2F;等待读取线程结束 （2）临界区资源buffer_has_item ​ if(buffer_has_item&#x3D;&#x3D;1){ ​ printf(“read：%s\\n”,buffer); ​ buffer_has_item&#x3D;0; ​ } ​ if(buffer_has_item&#x3D;&#x3D;0){ ​ printf(“write：%c\\n”,i+’a’); ​ sprintf(buffer,”%c”,i+’a’); ​ buffer_has_item&#x3D;1; ​ } 3.2互斥锁同步互斥方法实现3.2.1 条件变量同步互斥示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#define N 6int philosopher_num=0;//定义想吃的哲学家的数量int chopstick[N]=&#123;1,1,1,1,1,1&#125;;//初始化筷子数量pthread_mutex_t mutex;//定义对拿筷子的互斥访问pthread_mutex_t num;//定义对philosopher_num的互斥访问pthread_cond_t cond_Var;//定义条件变量 void pick_forks(int i)&#123; pthread_mutex_lock(&amp;num);//对临界资源上锁 philosopher_num++; printf(&quot;%d号哲学家想吃饭，共有%d个哲学家想吃饭\\n&quot;,i,philosopher_num); pthread_mutex_unlock(&amp;num);&#125;void return_forks(int i)&#123; pthread_mutex_lock(&amp;num);//对临界资源上锁 philosopher_num--; pthread_mutex_unlock(&amp;num); printf(&quot;%d号哲学家已吃完开始思考\\n&quot;,i);&#125;void* philosopher(void* arg)&#123; int i=*(int*)arg;//哲学家编号 pick_forks(i); pthread_mutex_lock(&amp;mutex); while(chopstick[i]==0||chopstick[(i+1)%N]==0) pthread_cond_wait(&amp;cond_Var,&amp;mutex);//判断i号哲学家左右两边是否有筷子，如果没有就等待 chopstick[i]--; chopstick[(i+1)%N]--; printf(&quot;%d eating\\n&quot;,i);//哲学家拿到筷子便开始吃饭 pthread_mutex_unlock(&amp;mutex); pthread_mutex_lock(&amp;mutex); chopstick[i]++; chopstick[(i+1)%N]++; return_forks(i);//哲学家吃完饭放下筷子开始思考 pthread_cond_signal(&amp;cond_Var);//i号哲学家吃完，告诉其他哲学家筷子可用 pthread_mutex_unlock(&amp;mutex); pthread_exit(0);&#125;int main(int argc,char* argv[])&#123; int i,arr[N]=&#123;0,1,2,3,4,5&#125;;//定义哲学家编号 pthread_mutex_init(&amp;mutex,NULL); pthread_mutex_init(&amp;num,NULL); pthread_cond_init(&amp;cond_Var,NULL); pthread_t phil[N]; for(i=0;i&lt;N;i++) &#123; pthread_create(phil+i,NULL,(void*)&amp;philosopher,&amp;arr[i]);//创建六个哲学家线程 &#125; for(i=0;i&lt;N;i++)//等待子线程结束 &#123; pthread_join(phil[i],NULL); &#125; return 0;&#125; 编译并执行： 执行结果： 3.2.2 条件变量同步互斥关键代码说明（1）想吃饭的哲学家数量为临界资源，对其进行上锁 ​ pthread_mutex_lock(&amp;num);&#x2F;&#x2F;对临界资源上锁​ philosopher_num–;​ pthread_mutex_unlock(&amp;num); （2）哲学家进行吃饭时，通过pthread_mutex_lock(&amp;mutex)对哲学家访问筷子临界资源进行上锁。当拿不到左右筷子时进行等待。while循环是为了被唤醒后继续进行条件判断。当条件满足时wait()将线程阻塞后会释放互斥锁lock,以便其他进程能访问共享变量。别唤醒后进行上锁，以免其他线程进入。 ​ pthread_mutex_lock(&amp;mutex); ​ while(chopstick[i]&#x3D;&#x3D;0||chopstick[(i+1)%N]&#x3D;&#x3D;0) pthread_cond_wait(&amp;cond_Var,&amp;mutex); chopstick[i]–; chopstick[(i+1)%N]–; printf(“%d eating\\n”,i);&#x2F;&#x2F;哲学家拿到筷子便开始吃饭 pthread_mutex_unlock(&amp;mutex); （3）哲学家吃完饭，放下筷子然后通过pthread_cond_signal(&amp;cond_Var)发送信号告诉其他哲学家他左右两边筷子可用，让等待的线程可以继续运行 pthread_mutex_lock(&amp;mutex); chopstick[i]++; chopstick[(i+1)%N]++; return_forks(i);&#x2F;&#x2F;哲学家吃完饭放下筷子开始思考 pthread_cond_signal(&amp;cond_Var);&#x2F;&#x2F;i号哲学家吃完告诉其他哲学家筷子可用 pthread_mutex_unlock(&amp;mutex); 3.3 信号量同步互斥方法实现3.3.1 信号量同步互斥示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;sem_t rw_mutex;//用于对读写进程互斥的访问sem_t mutex;//用于对read_count变量同步互斥的访问int read_count=0; void* reading(void* arg)&#123; sem_wait(&amp;mutex);//对临界资源read_count进行上锁 read_count++; if (read_count==1)//第一个读者拿到锁后，其他读者可以直接进入 sem_wait(&amp;rw_mutex); sem_post(&amp;mutex); printf(&quot;%d号读者正在读取数据！\\n&quot;,*(int*)arg); sem_wait(&amp;mutex); read_count--; if(read_count==0)//最后一个读者释放锁 sem_post(&amp;rw_mutex); sem_post(&amp;mutex); pthread_exit(0);&#125; void* writing(void* arg)&#123; while(1) &#123; sem_wait(&amp;rw_mutex);//争夺互斥量，与读进程进行互斥的访问 printf(&quot;正在写入数据！\\n&quot;); sem_post(&amp;rw_mutex); sleep(2); &#125;&#125;int main()&#123; int i,reader_id[5]=&#123;1,2,3,4,5&#125;;//定义读者编号 sem_init(&amp;rw_mutex,0,1); sem_init(&amp;mutex,0,1); pthread_t reader[5],writer; //创建写者线程 pthread_create(&amp;writer,NULL,(void*)&amp;writing,NULL); //创建5个读者线程 for(i=0;i&lt;5;i++) &#123; pthread_create(reader+i,NULL,(void*)&amp;reading,&amp;reader_id[i]); sleep(1); &#125; //等待读者线程结束，写线程中有while循环，不用等待它结束 for(i=0;i&lt;5;i++) &#123; pthread_join(reader[i],NULL); &#125; sem_destroy(&amp;rw_mutex); sem_destroy(&amp;mutex); return 0;&#125; 编译后执行： 运行结果： 3.3.2 信号量同步互斥关键代码说明（1）对读者线程，首先对read_count临界资源上锁，并将读者数量加1，如果是第一个读者拿到锁，那么其他读者不再需要与写者进行争夺锁便可以读取数据。 当剩最后一个读者时，读完数据后将读&#x2F;写进程锁释放。*(int*)arg为线程(读者)编号。 sem_wait(&amp;mutex); read_count++; if (read_count&#x3D;&#x3D;1) sem_wait(&amp;rw_mutex); sem_post(&amp;mutex); printf(“%d号读者正在读取数据！\\n”,(int)arg); sem_wait(&amp;mutex); read_count–; if(read_count&#x3D;&#x3D;0) sem_post(&amp;rw_mutex); sem_post(&amp;mutex); （2）写者进程通过while循环一直进行写操作,争躲到读&#x2F;写进程锁就可以进行数据写入 ​ while(1) ​ { ​ sem_wait(&amp;rw_mutex); ​ printf(“正在写入数据！\\n”); ​ sem_post(&amp;rw_mutex); ​ } （3）sem_post( ) 函数（函数原型 int sem_wait(sem_t * sem);） 作用是给信号量的值加上一个“1”。 当有线程阻塞在这个信号量上时，调用这个函数会使其中一个线程不在阻塞，选择机制是有线程的调度策略决定的。 ​ sem_wait ( ) 函数（函数原型 int sem_wait(sem_t * sem);）它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。 3.4屏障同步互斥方法实现3.4.1 屏障同步互斥示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define N 7 pthread_barrier_t barrier;//定义屏障double ave;//平均分int min,max;//最低分和最高分//计算去掉最低分和最高分之后的平均分void* average(int *arg)&#123; int i,sum=0; for(i=0;i&lt;N;i++) &#123; sum+=arg[i]; &#125; /*等待两个子线程找出最低分和最高分后，然后再来求平均分*/ pthread_barrier_wait(&amp;barrier);//到达屏障点,停止等待 /*等所有线程到达屏障点后,继续运行求出平均值在主线程中输出*/ ave=(sum-min-max)/(N-2.0); pthread_exit(0);&#125;//找到最低分void* mininum(int *arg)&#123; int i,j; min=arg[0]; for(i=0;i&lt;N;i++) &#123; if(arg[i]&lt;min) &#123; min=arg[i]; &#125; &#125; printf(&quot;The mininum value is %d\\n&quot;,min); pthread_barrier_wait(&amp;barrier);//到达屏障点,停止等待 pthread_exit(0);&#125;//找到最高分void* maxinum(int *arg)&#123; int i,j; max=arg[0]; for(i=0;i&lt;N;i++) &#123; if(arg[i]&gt;max) &#123; max=arg[i]; &#125; &#125; printf(&quot;The maxinum value is %d\\n&quot;,max); pthread_barrier_wait(&amp;barrier);//到达屏障点,停止等待 pthread_exit(0);&#125; int main(int argc,char* argv[])&#123; if(argc!=8) &#123; printf(&quot;请输入%d个数值\\n&quot;,N); return 0; &#125; int i,array[N]; for(i=0;i&lt;N;i++)//将命令行输入的参数存入数组中 &#123; array[i]=atoi(argv[i+1]); &#125; pthread_t tid1,tid2,tid3; /*初始化屏障，设置需到达屏障的数目为3(3个子线程)*/ pthread_barrier_init(&amp;barrier,NULL,4); pthread_create(&amp;tid1,NULL,(void*)&amp;average,array); pthread_create(&amp;tid2,NULL,(void*)&amp;maxinum,array); pthread_create(&amp;tid3,NULL,(void*)&amp;mininum,array); pthread_join(tid1,NULL);//等待tid1线程求出平均值，以免主线程先结束 printf(&quot;The final score is %.1f\\n&quot;,ave); pthread_barrier_destroy(&amp;barrier);//释放屏障资源 return 0;&#125; 编译代码： 运行结果： 3.4.2 屏障同步互斥关键代码说明 （1）对于求平均分线程，要等待两个子线程找出最低分和最高分后，才能求最后的得分。 通过设置屏障，等待其他线程到达该点后，继续并发执行求出最后的平均分ave。最后在主线程中输出平均分。 ​ for(i&#x3D;0;i&lt;N;i++) ​ { ​ sum+&#x3D;arg[i]; &#125; ​ pthread_barrier_wait(&amp;barrier);&#x2F;&#x2F;到达屏障点,停止等待 ​ ave&#x3D;(sum-min-max)&#x2F;(N-2.0); (2)对于另外两个子线程，当求出最大值和最小值后，表明自己的工作已经完成。并输出最大值和最小值。 ​ printf(“The maxinum value is %d\\n”,max); ​ pthread_barrier_wait(&amp;barrier); ​ printf(“The maxinum value is %d\\n”,max); ​ pthread_barrier_wait(&amp;barrier);","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yellowsy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"Web静态网页","slug":"Web静态网页","date":"2022-09-14T09:46:03.000Z","updated":"2022-09-17T08:06:26.823Z","comments":true,"path":"2022/09/14/Web静态网页/","link":"","permalink":"https://yellowsy.github.io/2022/09/14/Web%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/","excerpt":"","text":"1. 一个有趣的猜数游戏 该游戏会随机生成一个0-99之内的整数，你有十次猜数的机会，点击开始即可猜数。 猜数游戏 var rnd; var pID=null; var count //设置猜测次数：10次 function rand(){ rnd=parseInt(Math.floor(Math.random()*100)+1); //alert(rnd); return rnd; } rnd=rand(); function compare(){ var n= parseInt(document.guess.num.value); if(n>rnd) document.guess.rs.value=\"你猜大了！\"; if(n9?x:\"0\"+x } } function calculator(){ let display=document.getElementById(\"result\") let myDiv=document.getElementById(\"num\").getElementsByTagName(\"li\") //指定ul的所有li,以免影响到其他的li for(let i=0;i","categories":[{"name":"HTML","slug":"HTML","permalink":"https://yellowsy.github.io/categories/HTML/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"Linex命令","slug":"Linex命令","date":"2022-09-13T12:46:03.000Z","updated":"2022-09-15T14:58:02.922Z","comments":true,"path":"2022/09/13/Linex命令/","link":"","permalink":"https://yellowsy.github.io/2022/09/13/Linex%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1. 常用命令重启网卡12systemctl restart network service network restart 用户切换12su hsy（普通用户）su - (切换到root用户) 关机12345halt shutdown -h now (立即关机) shutdown -h +5(五分钟以后关机)shutdown -c (取消关机)init 0 (关机) ；init 6 (重启) 使用 “ ；”一次输入多个命令1command1 ; command2 ; command3 常用小技巧 显示或操作命令历史列表 1history 补全路径 文件或目录的首几个字母+Tab 显示上一条路径 Esc+. (点) 2. 操作文件和目录删除文件12345rm file 删除文件（可以不为空删除）rm -f flie 强制删除rm -r 目录名 递归删除目录（该目录下可以有其他文件，被一起删除）rmdir 删除空目录 创建目录1234mkdir--创建目录 mkdir dir1创建一个目录mkdir dir1 dir2 dir3 一次创建多个目录mkdir -p dir1/dir2 递归生成目录dir1和dir2,即dir1为当前目录的子目录，dir2为dir1的子目录 复制文件和目录123cp item1 item2 将文件或目录item1复制到item2cp -r 递归复制目录cp -p 保留源文件的属性不变 移动和重命名文件1mv item1 item2 将文件或目录item1移动或重命名为item2 创建硬链接和链接符号12345ln file link 创建硬链接 （就是为文件额外创建一个目录项）a.硬链接不能引用目录，只能引用文件b.硬链接不能跨物理设备ln -s item link 创建链接符号 （item可以是文件和目录）相当于用文本描述目标文件相对于符号链接的位置 3.初步探索Linux使用ls命令之乐123456. (一个点) 表示在当前目录ls 查看当前目录所包含的文件和子目录ls -l 将输出结果改成长格式ls -a 列出所有文件ls -d 显示目录本身的属性，而非其内部的文件列表 （只显示目录本身）ls -h 人性化显示容量信息，以K、M、G等单位表示文件大小。 使用file命令确定文件类型1file filename 使用less命令查看文本文件 键G 移动到文件末尾 键Q 退出less命令 通配符1234567* 匹配任意多个字符 ls -d /etc/*conf* 显示/etc目录下所有名字中包括“conf”的文件或目录。 ls -d /etc/pa* 列出/etc目录下所有以“pa”开头的文件或目录，j加上 -d 只显示目录本身,不显示其内容？ 匹配任意单个字符 ls -lh /dev/sa? 以长格式列出/dev目录中所有以“sd”开头并且文件名只有3个字符的文件信息。(sa给定，第三个字符任意(即？))通配符“[ ]”可以匹配指定范围内的任意单个字符。 ls /dev/[a-c]*列出/dev/目录中以“a”、“b”、“c”开头的所有文件。 时间戳 访问时间(access time:atime): 上一次文件访问时间； 内容修改时间(modified time:mtime): 上次文件内容修改时间； 元信息改变时间(change time:ctime): 上次文件属性改变时间； 1stat -[选项] [文件] 查看文件的元信息 4.和命令打交道识别命令1234显示命令类型 type command(要检查的文件名)显示可执行文件的位置 which command 获取命令文档123456789101112help--获取Shell内建命令的帮助信息 例如：help cd--help 显示用法信息 mkdir --helpman 显示命令的手册页 例如 man ls man section search_term ；section指明节号 man -k 根据关键字查找显示适合的命令清单（根据关键字查找） apropos partition(关键字)whatis --显示手册页的简述info--显示程序的info条目 使用alias创建自己的命令12alias name=&#x27;string&#x27; (name为自己所起的名字，string为命令)使用unalias命令可以删除别名 5.重定向标准输出重定向12345将ls -l /usr/bin 的输出结果保存在ls-output.txt中 ls - l/usr/bin &gt; ls-output.txt （ls的结果本来应该输出在屏幕上）将重定向的标准输出追加到文件尾，而不是将其从头覆盖 使用 &gt;&gt; : ls - l/usr/bin &gt;&gt; ls-output.txt&gt; 覆盖重定向 ； &gt;&gt; 追加重定向 标准错误重定向12标准错误重定向对应的描述符为2，以下将输出错误信息定向到 ls-error.txt例：ls -l /bin/usr 2&gt; ls-error.txt 标准输入重定向12345cat 将键盘输入的内容在屏幕上原样输出cat 命令读取一个或多个文件并将其复制到标准输出（显示文本文件内容）创建一个文件存放从键盘输入的字符 a.cat lazy_dog.txt （换行）The quick brown fox jumped over the lazy dog. b.查看lazy_dog .txt文件 例：cat lazy_dog.txt或者cat&lt;lazy_dog.txt 管道123456789101112131415161718192021管道符“|”用于连接左右两个命令，将“I”左边命令的执行结果作为“|”右边命令的输入 将标准输出的命令用less命令将其结果逐页显示出来 ls -l /usr/bin | less排序列表 ls /bin/usr/bin | sort | lessuniq--报告或忽略重复行 ls /bin/usr/bin | sort | uniq | lesswc 统计文件中换行符，单词以及直字节的数量 wc ls-error.txt (输出三个数字分别是：行数，单词数，字节数) wc -l 限制只输出文件行数grep 输出与模式匹配的行 grep pattren filename -i 使grep命令在搜索的时候忽略字母的大小写 -v 使grep命令只输出不匹配指定模式的行 -r 可以匹配关键字在当前目录下的子目录中查找 head/tall 输出文件的开头/结尾部分（默认十行） head -n 5 ls-output.txt (注意是文件) 运用在管道中：ls /usr/bin |tail -n 5 tail -f 持续观察文件，一旦文件中添加新行，立即显示在屏幕中，ctrl+c停止tee 读取标准输入并将输出结果写入标准输出的文件iddiff file1 file2 比较两个文件的不同；结果中的a,b,c分别代表添加，删除和修改;以&quot;&lt;&quot;开始的行属于文件1，以“&gt;”开始的行属于文件2。 6. Shell眼看世界123456789算术扩展(仅支持整数，不支持小数) echo $((expression)) echo $((2+2)) / : 除法 ，结果为整数 * : 求幂花括号扩展 echo Front-&#123;A,B,C&#125;-Back 结果：Front-A-Back Front-B-Back Front-C-Back echo &#123;01..15&#125; 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 7. 高级键盘技巧光表移动 Ctrl+A 将光标移动到首行 Ctrl+E 将光标移动到行尾 Ctrl+F 将光标v向前移动一个字符；等同于右方向键位 Ctrl+B 将光表向后移动一个字符；等同于左方向键位 Ctrl+L 清除屏幕，将光标移动到左上角。等同于clear命令 修改文本 Ctrl+D 删除光标处的字符 Ctrl+T 将光标出的字符与其之前的单词对调 剪切和粘贴文本 Ctrl+K 剪切从光标处到行尾的文本 Ctrl+U 剪切从光标处到行首的文本 Ctrl+Y 将kill-ring缓冲区内的文本粘贴到光标 搜索历史记录 Ctrl+P 移动到上一条搜索记录。等同于使用上方向建 Ctrl+N 移动到下一条搜索记录。等同于使用下方向建 Ctrl+R 反向增量搜索。从当前命令行开始向上增量搜索历史记录列表 Ctil+O 执行历史记录列表中的当前命令并移动到下一条命令。如果你想要重复执行历史列表中的一系列命令，该组合键非常方便 ！！ 重复上一条命令 ！number 重复命令历史记录列表中第number个命令 8. 文件访问权限文件权限修改 3种基本操作：读(r)， 写(w)， 执行(x)； 3类用户划分：文件拥有者(user)，文件所属组(group)，其他用户(other)； 文件访问权限可以使用命令chmod修改； chmod mode|octal-mode File… 按照mode或octal-mode描述的方式设置File的访问权限 mode: 字符形式描述的权限:[ugoa][-+&#x3D;][rwxXst] ugoa：u(拥有者)，g(所有组)，o(其他用户)，a(所有用户) stat命令查看文件元信息 文件类型 文件访问权限 -+&#x3D;：-(删除权限)，+(增加权限)，&#x3D;(重设权限) rwxXst：r(读)，w(写)，r(执行)，s(suid或sgid)，t(sticky bit) 12chmod a=rwx file 设置文件file的访问权限为所有用户可读/写/执行修改后file的文件权限为：-rwxrwxrwx . u=rwx g=rwx o=rwx octal-mode：八进制形式描述的权限：[-+&#x3D;][0-7]+ -+&#x3D;：-(删除权限)，+(增加权限)，&#x3D;(重设权限) [0-7]+：表示数0-7可重复多次，通常可以有4个 第1个八进制数表示特殊权限：4(suid)，2(sgid)，1(sticky bit) 第2个八进制数表示拥有者权限：4(r)，2(w)，1(x) 第3个八进制数表示所属组权限：4(r)，2(w)，1(x) 第4个八进制数表示其他用户权限：4(r)，2(w)，1(x) 文件默认权限umark掩码 显示或修改umask掩码(用于决定新建文件时如何赋予权限) umask掩码的默认值通常设置为002或022； 假设umask掩码值为022： 新建文件时：将文件权限设置为 666-022&#x3D;644，即rw-r–r–； 新建目录时：将目录权限设置为 777-022&#x3D;755，即rwxr-xr-x； umask 查看umask掩码值； umask nnn 临时修改umask掩码值为nnn(由3个八进制数组成)；","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yellowsy.github.io/categories/Linux/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"适合发朋友圈的文案","slug":"我的第一篇博客","date":"2022-09-12T12:19:21.000Z","updated":"2022-09-15T08:32:08.414Z","comments":true,"path":"2022/09/12/我的第一篇博客/","link":"","permalink":"https://yellowsy.github.io/2022/09/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1.梅花何止落满一整座南山 2.我已经懒得沟通了 你说夜里有太阳我都认爱哪里是神殿 分明是十里扬州、灯火不休你是落日弥漫的橘 天边透亮的星我与春风皆过客 你携秋水揽星河 3.梦里不觉人间晚 回首山河遍地秋空有一身热爱 却入不了这山海毕竟你是太阳 不是我一个人的光其实雨不大 是风搞得紧张 4.宫崎骏曾经说过 当陪你的那个人 要下车时 即使你在不舍 你也要心存感激 挥手告别 没个人的故事 开头都是极具温柔的 但往往故事的结尾都配不上整个开头 记住 没一个意难平的结果 都是我们最好的结局 5.爱意随风起 却不随风散 这路遥马急的人间 你在我心里何止好几年 6.“一定要文采斐然吗，我磕磕绊绊，叙意不清的语句也是爱一定要娓娓道来吗 我词不达意 语未由衷的叙述也是爱一定要妙语连珠吗 我支支吾吾 含糊其辞的言语也是爱啊。” 7.如果你喜欢冬天，那是因为有夏天的存在。那么人为什么要工作学习呢？是为了以后开心，如果你每天只是玩的话，那可能玩就不是一件特别开心的事。所以人要有束缚才会有自由，有痛苦才会有快乐。只有在忙碌的时候才能体会到闲暇的愉悦。光明也只有在黑暗中看到。","categories":[{"name":"文案","slug":"文案","permalink":"https://yellowsy.github.io/categories/%E6%96%87%E6%A1%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://yellowsy.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yellowsy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"HTML","slug":"HTML","permalink":"https://yellowsy.github.io/categories/HTML/"},{"name":"Linux","slug":"Linux","permalink":"https://yellowsy.github.io/categories/Linux/"},{"name":"文案","slug":"文案","permalink":"https://yellowsy.github.io/categories/%E6%96%87%E6%A1%88/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"生活","slug":"生活","permalink":"https://yellowsy.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务器+宝塔快速搭建网站</title>
      <link href="/2022/11/20/%E6%9C%8D%E5%8A%A1%E5%99%A8+%E5%AE%9D%E5%A1%94%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/"/>
      <url>/2022/11/20/%E6%9C%8D%E5%8A%A1%E5%99%A8+%E5%AE%9D%E5%A1%94%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>我们可以选择在服务器中构建 LNPM 或者 LAPM 环境来搭建我们的个人网站，如果进行手动配置，对于没有学习过 linux 的人来说，可能有些困难，配置过程中也可能会出现各种错误。所以对于我们这些小白来说，有没有更简单便捷的方法，让我们能够快速的搭建个人网站呢？</p><p>接下来我们就来介绍一下使用宝塔和 Typecho 主题模板站快速搭建我们的个人网站，不需要你学习任何新的知识，直接一键安装我们所需要的环境，在 Typecho 可以任意选择我们喜欢的主题部署到我们个人网站中。</p><h3 id="服务器的选择"><a class="markdownIt-Anchor" href="#服务器的选择">#</a> 服务器的选择</h3><ol><li><p>首先我们需要有一台服务器，作为学生，我们可以去<a href="https://www.aliyun.com/">阿里云</a>或者<a href="https://cloud.tencent.com/">腾讯云</a>进行学生认证，以更便宜的价格去购买我们所需要的服务器，你也可以在活动的时候购买，毕竟一台云主机也不便宜。不过你也可以去白嫖一个月的云主机 ECS，去体验一下。如果想长期搭建自己的个人网站，最好还是去购买一台云主机。</p></li><li><p>我这里是免费试用一个月的阿里云的云主机，去阿里云官网，首页中选择云主机 ECS，因为我还没有购买过云主机，所以可以免费试用一个月。这里可以看到我们云主机的公网 ip 地址。</p><p><img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221611242.png" alt></p></li><li><p>选择实例，点击更多选择，选择重置实例密码，设置我们远程登录的用户名和密码。</p></li></ol><h3 id="下载ssh远程连接工具及连接"><a class="markdownIt-Anchor" href="#下载ssh远程连接工具及连接">#</a> 下载 ssh 远程连接工具及连接</h3><ul><li>推荐两款好用的远程连接工具 Xshell 和 finalshell，需要说明的是，Xshell7 之后就开始收费了，你可以进行破解或者进行学生认证进行下载。finalshell 则是免费的。</li><li>我们可以直接去官网下载 finalshell：<a href="http://www.hostbuf.com/t/988.html">下载地址</a>。Xshell 可以自行百度破解安装，<a href="https://www.xshell.com/zh/">官网</a>。</li><li>使用我们下好的工具 (我这里使用 Xshell)，通过公网 IP 进行连接。</li></ul><h3 id="安装宝塔面板"><a class="markdownIt-Anchor" href="#安装宝塔面板">#</a> 安装宝塔面板</h3><ol><li><p>首先来到宝塔的官网，点击安装选择对应的系统，复制下载命名粘贴到我们的命令行中，直接进行下载，最后我们会得到外网面板地址，内网面板地址，随机的用户名和密码。</p><p><img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221616345.png" alt></p></li><li><p>在浏览器中输入我们刚获得的外网面板地址，使用用户名和密码继续登录。登陆后，它会让你选择安装 LNPM 或 LAPM 服务，我们选择 LNPM，直接点击一键安装，它会自己帮我们配置好这些服务。然后点击网站选择 php 项目，点击添加站点，输入我们的公网 ip，点击确认。下面是我已经添加好的站点。<img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221616228.png" alt></p></li></ol><h3 id="下载typecho"><a class="markdownIt-Anchor" href="#下载typecho">#</a> 下载 Typecho</h3><ol><li>去浏览器搜索 Typeche，进入官网，点击下载正式版。下载后为压缩文件。<img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221617082.png" alt></li><li>下载好后我们来到宝塔面板，选择文件页面，里面有默认的几个页面，可以把全部的都删除。接下来点击上传，选择我们刚刚下载好的压缩包。上传后，在后面的选项中点击加压，注意解压到我们的 /www/ wwwroot/112.74.57.192 目录下，解压后如下图：<img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221618667.png" alt></li></ol><h3 id="创建数据库然后再installphp页面中配置我们创建的数据库"><a class="markdownIt-Anchor" href="#创建数据库然后再installphp页面中配置我们创建的数据库">#</a> 创建数据库，然后再 install.php 页面中配置我们创建的数据库</h3><ol><li><p>选择数据库，点击添加数据库，设置数据库名，用户名和密码。</p><p><img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221626719.png" alt></p></li><li><p>再浏览器地址栏中输入 112.74.57.192/install.php (注意对应自己的公网 ip)，配置我们刚刚创建的数据库相应的信息。</p><img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221627560.png" style="zoom:67%;"> <p>配置好后，点击确认，开始安装按钮。我们就会来到控制台页面，这里可以直接进行我们网站页面的编写，可以修改我们的外观，编写文章等。<img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221635055.png" alt></p></li></ol><h3 id="进入typecho主题模板站下载我们自己喜欢的主题"><a class="markdownIt-Anchor" href="#进入typecho主题模板站下载我们自己喜欢的主题">#</a> 进入 Typecho 主题模板站，下载我们自己喜欢的主题</h3><ol><li><p>在浏览器中搜索 Typecho 主题模板站，进入后下载我们需要的主题。</p></li><li><p>来到我们宝塔控制面板，点击文件页面，点击 usr 文件夹，里面有个 themes 文件夹，点击进入，然后选择上传文件，上传我们刚刚下载好的主题模板，然后进行解压，修改解压后的文件名，去掉 - master。</p><p><img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221636346.png" alt></p></li></ol><h3 id="修改我们网站的主题"><a class="markdownIt-Anchor" href="#修改我们网站的主题">#</a> 修改我们网站的主题</h3><ol><li><p>进入我们控制台页面 (112.74.57.192/admin，admin 为我们刚刚创建的数据库名称)，点击控制台下拉列表中的外观，进去可以看到我们刚刚上传的主题。</p><img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221636796.png" style="zoom:67%;"> </li><li><p>选择我们刚刚上传的主题，点击启用。<img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221637520.png" alt></p></li><li><p>然后去浏览器输入公网 IP 进行访问，可以看到已经成功修改了我们的主题<img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211202336737.png" alt></p></li><li><p>如何自定义网站背景图片和头像</p><ul><li><p>首先在 /www/ wwwroot/112.74.57.192 目录下新建一个 img 文件夹，然后上传我们自己的图片</p><img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221637179.png" style="zoom:80%;"> </li><li><p>在设置外观界面，图像设置填写 img 文件夹图片的路径，如图所示：</p><img src="https://raw.githubusercontent.com/yellowsy/cloudimg/main/img/202211221637059.png" style="zoom:80%;">    </li></ul></li></ol><p>至此，我们已经通过宝塔 + Typecho 快速搭建好我们的个人网站。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7配置nginx解析php脚本文件</title>
      <link href="/2022/11/20/Centos7%E9%85%8D%E7%BD%AEnginx%E8%A7%A3%E6%9E%90php%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/"/>
      <url>/2022/11/20/Centos7%E9%85%8D%E7%BD%AEnginx%E8%A7%A3%E6%9E%90php%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>继上篇我们安装好 nginx 和 php 服务之后，接下来我们配置 nginx 解析 html 文件夹下的 php 文件。当我们安装好 nginx 服务后，我们输入虚拟机的 ip 地址时候，我们默认访问的时 80 端口，它默认显示们 /usr/local/nginx/html (这里根据你自己安装的位置) 文件夹下的 index.html 文件，即 nginx 的默认访问主页。如果我们想放置 php 文件进行访问，就必须配置 nginx 能够解析 php 脚本。接下来演示如何配置 nginx 服务通过 https (http+ssl) 进行访问以及解析 php 脚本文件。</p><h3 id="nginx配置https访问"><a class="markdownIt-Anchor" href="#nginx配置https访问">#</a> nginx 配置 https 访问</h3><ol><li><p>要配置 https 服务，首先 nginx 要支持 ssl 协议，如果是 yum 方式安装的，它会默认帮你下载 ssl 模块。注意如果是源码方式安装的，在进行编译安装时，需要加上 <code>--with-http_ssl_module</code>  选项 (参考我上篇文章)</p></li><li><p>生成自签名证书 (不受信任) 或去 ca 机构免费申请一个 https 证书 (受信任)，这里演示自签名证书。如果是想搭建网站，可以去申请一个证书。然后配置 nginx.conf 文件中的 https 服务。</p><ul><li><p>第一步：生成公钥和私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rsa非对称加密算法</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cret.key 私钥，这个可以自己命名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cret.pem 公钥，用样这个也可以自己命名</span></span><br><span class="line">openssl req -newkey rsa:4096 -nodes -keyout cret.key -x509 -days 365 -out cert.pem </span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201535200.png" alt></p><p>运行该命令之后，会在当前文件夹下生成 cret.key 和 cret.pem 两个文件。</p></li><li><p>第二步：配置 /usr/local/nginx/conf/nginx.conf 文件，可以先备份，以免误操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/nginx/conf/nginx.conf /usr/local/nginx/conf/nginx.conf_bak</span><br><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>打开 server {listen 443} 那段代码注释，如果没有直接添加，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 443 ssl ;</span><br><span class="line">server_name Localhost ;</span><br><span class="line">ssl certificate&quot;/usr/Local/nginx/SSL/cert.pem&quot;; #对应自己的公钥地址 </span><br><span class="line">ssl_ certificate_ key&quot;/usr/local/nginx/SSL/cert.key&quot;; #对应自己的私钥地址</span><br><span class="line">ssl session cacheshared:SSL: 1m;</span><br><span class="line">ssl session timeout5m;</span><br><span class="line">ssl_ ciphersHIGH:!aNULL:!MD5;</span><br><span class="line">ssl prefer server_ cipherson;</span><br><span class="line">Location / &#123;</span><br><span class="line">roothtml ;</span><br><span class="line">index index . html index . htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201551087.png" alt></p></li></ul></li><li><p>最后去浏览器验证 https 是否配置成功。</p><ul><li><p>在浏览器中输入 https:// 虚拟机 ip 地址</p><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201555640.png" alt></p></li><li><p>这里不安全是因为我们使用的是自签名证书，没关系，点击继续前往，就可以访问我们的主页了。</p></li></ul></li></ol><h3 id="配置nginx解析php脚本文件"><a class="markdownIt-Anchor" href="#配置nginx解析php脚本文件">#</a> 配置 nginx 解析 php 脚本文件</h3><ol><li><p>上一篇文章我们使用 Remi 模块安装的 php 服务，所以一些配置文件路径和 yum 直接安装的有些区别，这都无伤大雅，重要是如何配置这么文件？有那些文件需要配置？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前PHP内存限制低于推荐值512MB。</span></span><br><span class="line">vim /etc/opt/remi/php74/php.ini</span><br><span class="line">memory_limit = 512M</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果你运行的是nginx而不是apache，修改</span></span><br><span class="line">vim /etc/opt/remi/php74/php-fpm.d/www.conf</span><br><span class="line">user = apache</span><br><span class="line">group = apache</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replace the values with</span></span><br><span class="line">user = nginx</span><br><span class="line">group = nginx</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>php.ini</strong> 文件： <code>vim /etc/opt/remi/php74/php.ini</code></p><ul><li><p>找到 <strong>memory_limit</strong> 一行，将其改成 <strong>512M</strong>：</p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201604395.png" style="zoom:67%;">  </li><li><p>将 <strong>cgi.fix_pathinfo</strong> 值设置为 <strong>0</strong>：</p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201605159.png" style="zoom:67%;"> </li></ul></li><li><p>创建用户 nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd nginx</span><br><span class="line">useradd -g nginx nginx</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>www.conf</strong> 文件，将<strong> user</strong> 和 <strong>group</strong> 的值都改成 <strong>nginx</strong>：</p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201606999.png" style="zoom:67%;"> </li><li><p>执行如下命令将 <strong>php74</strong> 链接到系统环境变量中，就可以任意地方使用 <strong>php -v</strong> 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/remi/php74/root/usr/bin/php /usr/bin/php</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201607106.png" style="zoom:67%;"> </li><li><p>修改 nginx 配置文件: <code>vim /usr/local/nginx/conf/nginx.conf</code></p><ul><li><p>首先去掉 <strong>user</strong> 注解，将其值改成 <strong>nginx</strong>：</p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201609672.png" style="zoom:67%;"> </li><li><p>接着修改 <strong>location</strong> 块，追加 <strong>index.php</strong> 让 <strong>nginx</strong> 服务器默认支持 <strong>index.php</strong> 为首页：</p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201610860.png" style="zoom:67%;"> </li><li><p>最后配置 <strong>PHP</strong> 部分:</p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201610383.png" style="zoom:67%;"> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">     fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">     fastcgi_index  index.php;</span><br><span class="line">     fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">     include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>最后我们在 /usr/local/nginx/html 下编写一个 php 测试文件，然后去浏览器进行访问。</p><ul><li><p>测试文件 test.php 内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php</span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>(); <span class="comment">#可以排查配置php是是否出错或漏配置模块</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在浏览器输入 https:// 虚拟机 ip 地址 /test.php，可以看到能成功输出。</p><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211201615194.png" alt></p></li></ul></li></ol><p>至此我们所有配置基本完成，如果有兴趣可以学习一下 php 动态网页编程语言，编写更加好看的网页页面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7中安装Nginx和PHP服务</title>
      <link href="/2022/11/18/Centos7%E4%B8%AD%E5%AE%89%E8%A3%85Nginx%E5%92%8CPHP%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/11/18/Centos7%E4%B8%AD%E5%AE%89%E8%A3%85Nginx%E5%92%8CPHP%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="nginx和php能干吗"><a class="markdownIt-Anchor" href="#nginx和php能干吗">#</a> Nginx 和 PHP 能干吗？</h3><p>我们要想要搭建自己的网站时，我们可以在 linux 服务器中配置 LNPM (Linux，Nginx，PHP，Mysql) 或 LAPM (Apache) 实现网站的搭建与访问，Nginx 作为 web 服务器，可以将我们自己编写的 html 静态网页文件部署到服务器中，然后通过 ip 地址加端口号进行访问。但我们的页面不可能都是一些静态页面，网站应该能和后台数据进行交互，所以我们可以用到 PHP 这个技术，它是一种用于创建动态和交互式 HTML 网页的脚本语言。接下来我们简单配置一下这两个服务。</p><h3 id="源码安装和yum安装的区别与选择"><a class="markdownIt-Anchor" href="#源码安装和yum安装的区别与选择">#</a> 源码安装和 yum 安装的区别与选择</h3><h4 id="yum安装"><a class="markdownIt-Anchor" href="#yum安装">#</a> yum 安装：</h4><p>yum 相当于是自动化帮你安装，你不用管软件的依赖关系，在 yum 安装过程是帮你把软件的全部依赖关系帮你傻瓜式的解决了。而且现在 Centos7 的服务启动已经换成 systemctl 命令来控制了。通过 yum 安装会帮你自动注册服务，你可以通过 systemctl start xxx.service 启动服务，方便快捷。但是缺点是 yum 安装你没办法干预，安装的目录也是分散的。你可能要执行 whereis 或者 find 命令去找 yum 安装的路径。有时候 yum 安装的软件版本比较低，你不得不去找其他的 yum 源，或者 rpm 包。</p><h4 id="源码安装"><a class="markdownIt-Anchor" href="#源码安装">#</a> 源码安装：</h4><p>源码编译在安装过程中可能要解决很多的依赖问题，才能装好一个软件。装好的软件你还不能通过 systemctl 来启动服务，因为在 /usr/lib/systemd/system/ 路径下并没有你的服务的配置文件，你要自己手写一个。但是好处在于你能选择软件的版本，自定义安装目录，安装的模块。更加灵活方便。</p><h3 id="源码方式安装nginx服务"><a class="markdownIt-Anchor" href="#源码方式安装nginx服务">#</a> 源码方式安装 Nginx 服务</h3><ol><li><p>首先可以去<a href="https://nginx.org/en/download.html">官网</a>选择自己需要的版本进行下载，然后上传到我们的 Centeos7 中任意位置进行解压。</p><img src="/2022/11/18/Centos7%E4%B8%AD%E5%AE%89%E8%A3%85Nginx%E5%92%8CPHP%E6%9C%8D%E5%8A%A1/202211182321182.png" style="zoom:67%;"> </li><li><p>安装所必须的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装gcc</span></span><br><span class="line">yum install -y gcc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装perl库</span></span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装zlib库</span></span><br><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></li><li><p>编译安装，进入 nginx-1.23.1 目录中</p><ol><li><p><code>.configure --prefix=/usr/local/nginx --with-http_ssl_module</code></p><ul><li><p>参数： <code>--prefix=/usr/local/nginx</code>  用来指定安装位置</p><p><code>--with-http_ssl_module</code>  是 nginx 支持 ssl，用来配置 https 进行访问</p></li></ul></li><li><p><code>make &amp;&amp; make install</code></p></li><li><p>启动 nginx，进入安装好的目录: <code>cd /usr/local/nginx/sbin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./nginx 启动</span><br><span class="line">./nginx -s stop 快速停止</span><br><span class="line">./nginx -s quit 优雅关闭，在退出前完成已经接受的连接请求</span><br><span class="line">./nginx -s reload 重新加载配置</span><br></pre></td></tr></table></figure></li></ol></li><li><p>安装完成后，将 nginx 配置为系统服务</p><ul><li><p>创建服务脚本: <code>vim  /usr/lib/systemd/system/nginx.service</code></p></li><li><p>服务脚本内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - web server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">ExecQuit=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>重新加载系统服务： <code>systemctl daemon-reload</code></p></li><li><p>启动服务： <code>systemctl start nginx.service</code></p></li><li><p>开机启动： <code>systemctl enable nginx.service</code></p></li></ul></li><li><p>关闭防火墙或放行端口，使我们在物理机中也能访问</p><ol><li><p>关闭防火墙： <code> systemctl stop firewalld.service</code></p></li><li><p>放行端口，nginx 默认对应 80 端口： <code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code></p><p>放行端口号需要重新加载防火墙： <code>firewall-cmd --reload</code></p></li></ol></li><li><p>测试 nginx 是否安装成功</p><ul><li><p>首先查看 Centos7 中对应的 ip 地址</p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211182349775.png" style="zoom:67%;"> </li><li><p>到我们的物理机中输入刚刚的地址，就可以看到 nginx 的首页（这个首页更改过）</p><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211182346270.png" alt></p></li></ul></li></ol><h3 id="yum方式安装php服务"><a class="markdownIt-Anchor" href="#yum方式安装php服务">#</a> yum 方式安装 php 服务</h3><p>注意：直接使用 <code>yum install php</code>  安装，安装的版本过低，所以我们选择其他源，使用 Remi 模块并进行安装，这里选择版本 PHP7.4。还有 <code>yum insatll php</code>  不会默认安装 php-fpm，这需要我们自己添加。</p><ol><li><p>首先需要添加两个源，不然安装会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">php高版本的yum源地址，有两部分，其中一部分是epel-release，另外一部分来自webtatic。</span></span><br><span class="line">rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">rpm -Uvh http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure></li><li><p>添加相关的库后，启用 PHP 7.4 的 Remi 模块并进行安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf -y install dnf-utils</span><br></pre></td></tr></table></figure></li><li><p>安装需要的模块，你可以通过 <code>yum search php74*</code>  查看有那些模块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">php74-php：用于创建动态web的PHP脚本语言网站</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">php74-php-fpm：PHP FastCGI进程管理器</span></span><br><span class="line">yum install php74-php php74-php-fpm</span><br></pre></td></tr></table></figure></li><li><p>运行并查看版本， 重启命令， 添加自动启动，链接 php 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行并查看版本</span></span><br><span class="line">php74 -v</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启命令php-fpm</span></span><br><span class="line">systemctl restart php74-php-fpm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加自动启动</span></span><br><span class="line">systemctl enable php74-php-fpm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看php7.4的安装路径</span></span><br><span class="line">whereis php74</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">链接php文件,这样可以在任意地方使用它</span></span><br><span class="line">ln -s /opt/remi/php74/root/usr/bin/php /usr/bin/php</span><br></pre></td></tr></table></figure></li><li><p>然后我们编写 php 文件进行测试。</p><ul><li><p>编写 php 文件： <code>vim hello.php</code></p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211190004433.png" style="zoom:67%;"> </li><li><p>授予它可运行权限， <code>chmod +x hello.php</code></p></li><li><p>运行 hello.php： <code>./hello.php</code></p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211190009642.png" style="zoom: 80%;"> </li></ul></li><li><p>至此，我们两个服务已经搭建完成，接下来我们就可以配置 nginx 可以解析 php 文件，这样我们放在 html / 目录下的 php 文件可以通过 nginx 进行访问了，如何配置两个服务一同工作，请移步到下一篇文章。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写shell脚本并启动</title>
      <link href="/2022/09/25/%E7%BC%96%E5%86%99shell%E8%84%9A%E6%9C%AC%E5%B9%B6%E5%90%AF%E5%8A%A8/"/>
      <url>/2022/09/25/%E7%BC%96%E5%86%99shell%E8%84%9A%E6%9C%AC%E5%B9%B6%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一-创建并执行shell脚本"><a class="markdownIt-Anchor" href="#一-创建并执行shell脚本">#</a> 一， 创建并执行 Shell 脚本</h3><h5 id="1-脚本文件格式"><a class="markdownIt-Anchor" href="#1-脚本文件格式">#</a> 1. 脚本文件格式</h5><ul><li>编写一个脚本。 Shell 脚本就是普通的文本文件。所以我们需要一个文本编辑器来书写它们。最好的文本 编 辑器都会支持语法高亮，这样我们就能够看到一个脚本关键字的彩色编码视图。语法高亮会帮助我们查看某 种常见 错误。为了编写脚本文件，vim，gedit，kate，和许多其它编辑器都是不错的候选者。</li><li>使脚本文件可执行。 系统会相当挑剔不允许任何旧的文本文件被看作是一个程序，并且有充分的理由！所以 我们需要设置脚本文件的权限来允许其可执行。</li><li>把脚本放置到 shell 能够找到的地方 当没有指定可执行文件明确的路径名时，shell 会自动地搜索某些目录， 来查找此可执行文件。为了最大程度的方便，我们会把脚本放到这些目录当中。</li></ul><h5 id="2-创建一个hello_world文件使用vim编辑"><a class="markdownIt-Anchor" href="#2-创建一个hello_world文件使用vim编辑">#</a> 2. 创建一个 hello_world 文件，使用 vim 编辑</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是我们的第一个脚本文件</span></span><br><span class="line"></span><br><span class="line">echo &#x27;Hello world!&#x27;</span><br></pre></td></tr></table></figure><h5 id="3-可执行权限"><a class="markdownIt-Anchor" href="#3-可执行权限">#</a> 3. 可执行权限</h5><ul><li>使得脚本能够执行，用 chmod 设置权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chomd 755 hello_world(文件名)</span></span><br></pre></td></tr></table></figure><h5 id="4-执行脚本"><a class="markdownIt-Anchor" href="#4-执行脚本">#</a> 4. 执行脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello_world</span></span><br></pre></td></tr></table></figure><p>​执行结果：</p><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211241148166.png" alt></p><h3 id="二编写html并在浏览器启动"><a class="markdownIt-Anchor" href="#二编写html并在浏览器启动">#</a> 二，编写 html 并在浏览器启动</h3><h5 id="1-变量与常量"><a class="markdownIt-Anchor" href="#1-变量与常量">#</a> 1. 变量与常量</h5><ul><li>Shell 并不在意变量赋值的数据类型，它将一切都视为字符串，可以之接为变量赋值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title=&quot;System Infomation Report&quot;</span><br><span class="line">使用 &#x27;$&#x27; 符号引用变量</span><br><span class="line">echo $title 输出即为: System Infomation Report</span><br></pre></td></tr></table></figure><hr><ul><li>#a=z     将字符串 z 赋给变量 a</li><li>#b=“a string” 内嵌空格符的字符串必须放入双引号中</li><li>#c=“a string and $b”  赋值中包含其他扩展（例如，变量扩展）</li><li>#d=&quot;$(ls -l foo.txt)&quot;   命令的执行结果</li><li>#e=$((5*7))   算术扩展</li><li>#f=&quot;\t\ta string \n&quot;   转义序列，例如制表符，换行符</li></ul><hr><h5 id="2-编写文件内容"><a class="markdownIt-Anchor" href="#2-编写文件内容">#</a> 2. 编写文件内容</h5><ul><li>创建文件 sys_info_page，输入下列程序：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">程序输出一个系统信息页</span></span><br><span class="line">TITLE=&quot;System Information Report For $HOSTNAME&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成时间</span></span><br><span class="line">CURRENT_TIME=&quot;$(date +&quot;%x %r %Z&quot;)&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建者用户名</span></span><br><span class="line">TIMESTAMP=&quot;Generated $CURRENT_TIME ,by $USER&quot;</span><br><span class="line">echo &quot;&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;$TITLE&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 align=&quot;center&quot;&gt;$TITLE&lt;/h1&gt;</span><br><span class="line">&lt;p align=&quot;center&quot;&gt;$TIMESTAMP&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;&quot;</span><br></pre></td></tr></table></figure><p><code>说明：$HOSTNAME为主机名，$(date + &quot;%x %r %Z&quot;)为当前用户时间</code></p><ul><li>设置 sys_info_page 可执行权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 755 sys_info_page</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sys_info_page</span></span><br></pre></td></tr></table></figure><ul><li>当程序运行的时候，我们应该看到 HTML 文本在屏幕上显示出来，因为脚本中的 echo 命令会输出 发送到标准 输出。我们再次运行这个程序，把程序的输出重定向到文件 sys_info_page.html 中， 从而我们可以通过网络浏 览器来查看输出结果：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sys_info_page &gt; sys_info_page.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">firefox sys_info_page.html</span></span><br></pre></td></tr></table></figure><p>​执行结果：<img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211241149118.png" alt></p><ul><li>也可在浏览器地址栏中输入：file:// 文件所在路径，进行查看</li></ul><h5 id="here-documents"><a class="markdownIt-Anchor" href="#here-documents">#</a> Here Documents</h5><ul><li>我们已经知道了两种不同的文本输出方法，两种方法都使用了 echo 命令。还有第三种方法，叫做 here document 或者 here script。一个 here document 是另外一种 I/O 重定向形式，我们 在脚本文件中嵌入正文 文本，然后把它发送给一个命令的标准输入。它这样工作：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; token</span><br><span class="line">text</span><br><span class="line">token</span><br></pre></td></tr></table></figure><ul><li><p>这里的 command 是一个可以接受标准输入的命令名，token 是一个用来指示嵌入文本结束的字符串。</p></li><li><p>这个字符串_EOF_（意思是 “文件结 尾”， 一个常见用法）被选作为 token，并标志着嵌入文本的结尾。注意这个 token 必须在一行中单独出现， 并且文本行中 没有末尾的空格。</p></li></ul><p>来看以下命令行示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">foo=<span class="string">&quot;some text&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;&lt; <span class="string">_EOF_</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">$foo</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&quot;$foo&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27;$foo&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">\$foo</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">_EOF_</span></span></span><br><span class="line">some text</span><br><span class="line">&quot;some text&quot;</span><br><span class="line">&#x27;some text&#x27;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">foo</span></span><br></pre></td></tr></table></figure><ul><li><p>正如我们所见到的，shell 根本没有注意到引号。它把它们看作是普通的字符。这就允许我们 在一个 here document 中可以随意的嵌入引号。</p></li><li><p>如果我们把重定向操作符从 “&lt;&lt;” 改为 “&lt;&lt;-”，shell 会忽略在此 here document 中开头的 tab 字符。</p></li></ul><h3 id="三shell函数"><a class="markdownIt-Anchor" href="#三shell函数">#</a> 三，Shell 函数</h3><h5 id="1-shell函数两种语法形式"><a class="markdownIt-Anchor" href="#1-shell函数两种语法形式">#</a> 1. shell 函数两种语法形式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function name &#123;</span><br><span class="line">  commands</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line">注意name和 &#x27;&#123;&#x27; 之间有空格</span><br></pre></td></tr></table></figure><p>​另一种简单的形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name &#123;</span><br><span class="line">  commands</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-shell函数用法"><a class="markdownIt-Anchor" href="#2-shell函数用法">#</a> 2. shell 函数用法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Shell 函数展示</span></span><br><span class="line"></span><br><span class="line">function step2 &#123;  //函数名与 &#x27;&#123;&#x27; 之间有空格</span><br><span class="line">echo &quot;Step 2&quot;</span><br><span class="line">return </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">主函数起点</span></span><br><span class="line"></span><br><span class="line">echo &quot;Step 1&quot;</span><br><span class="line">step2</span><br><span class="line">echo &quot;Step 3&quot;</span><br></pre></td></tr></table></figure><p>随着 shell 读取这个脚本，它会跳过第 1 行到第 11 行的代码，因为这些文本行由注释和函数定义组成。 从第 12 行 代码开始执行，有一个 echo 命令。第 13 行会调用 shell 函数 funct，然后 shell 会执行这个函数， 就如执行其 它命令一样。这样程序控制权会转移到第六行，执行第二个 echo 命令。然后再执行第 7 行。 这个 return 命令终 止这个函数，并把控制权交给函数调用之后的代码（第 14 行），从而执行最后一个 echo 命令。注意为了使函数 调用被识别出是 shell 函数，而不是被解释为外部程序的名字，<strong>所以在脚本中 shell 函数定义必须出现在函数调 用之前。</strong></p><h3 id="四局部变量"><a class="markdownIt-Anchor" href="#四局部变量">#</a> 四，局部变量</h3><ul><li><p>局 部变量只能在定义它们的 shell 函数中使用，并且一旦 shell 函数执行完毕，它们就不存在了。 拥有局部变量允许程序员使用的局部变量名，可以与已存在的变量名相同，这些变量可以是全局变量， 或者是其 它 shell 函数中的局部变量，却不必担心潜在的名字冲突。</p><p>下面的例子演示局部变量的定义和用法：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">local-vars: 演示本地变量的脚本</span></span><br><span class="line"></span><br><span class="line">foo=0 # global variable foo</span><br><span class="line"></span><br><span class="line">funct_1 () &#123;</span><br><span class="line">local foo # variable foo local to funct_1</span><br><span class="line">foo=1</span><br><span class="line">echo &quot;funct_1: foo = $foo&quot;</span><br><span class="line">&#125;</span><br><span class="line">funct_2 () &#123;</span><br><span class="line">local foo # variable foo local to funct_2</span><br><span class="line">foo=2</span><br><span class="line">echo &quot;funct_2: foo = $foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;global: foo = $foo&quot;</span><br><span class="line">funct_1</span><br><span class="line">echo &quot;global: foo = $foo&quot;</span><br><span class="line">funct_2</span><br><span class="line">echo &quot;global: foo = $foo&quot;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211241150476.png" alt></p><p>正如我们所看到的，通过在变量名之前加上单词 local，来定义局部变量。这就创建了一个只对其所在的 shell 函 数起作用的变量。在这个 shell 函数之外，这个变量不再存在。我们对两个 shell 函数中的局部变量 foo 赋值，不会影响到在函数之外定义的变量 foo 的值。 这个功能就允许 shell 函数能保持各自以及与它们所在脚本之间的独立性。</p><h3 id="五完善我们的shell脚本"><a class="markdownIt-Anchor" href="#五完善我们的shell脚本">#</a> 五，完善我们的 Shell 脚本</h3><ul><li>在我们已编写的 Shell 脚本中添加以下功能：<ul><li>系统正常运行时间和负载。这是自上次关机或重启之后系统的运行时间，以及在几个时间间隔内当前运行在 处理 中的平均任务量。</li><li>磁盘空间。系统中存储设备的总使用量。</li><li>家目录空间。每个用户所使用的存储空间数量。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令介绍：</span><br><span class="line">uptime  系统正常运行时间和负载</span><br><span class="line">df -h   查看文件系统硬盘使用情况  -h参数：使用人们习惯的 KB、MB 或 GB 等单位自行显示容量；</span><br><span class="line">du -sh /home/* 查看home文件夹磁盘占用情况  需要root用户权限，如果在普通用户下，在命令前加上sudo</span><br></pre></td></tr></table></figure><p>改写我们的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">程序输出一个系统信息页</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">大写字母表示常量，小写字母表示变量</span></span><br><span class="line">TITLE=&quot;System Information Report For $HOSTNAME&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成时间</span></span><br><span class="line">CURRENT_TIME=&quot;$(date +&quot;%x %r %Z&quot;)&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建者用户名</span></span><br><span class="line">TIMESTAMP=&quot;Generated $CURRENT_TIME ,by $USER&quot;</span><br><span class="line"></span><br><span class="line">report_uptime () &#123; </span><br><span class="line">cat &lt;&lt;- _EOF_</span><br><span class="line">&lt;h2&gt;System Uptime&lt;/h2&gt;</span><br><span class="line">&lt;pre&gt;$(uptime)&lt;/pre&gt;</span><br><span class="line">_EOF_</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">report_disk_space () &#123;</span><br><span class="line">cat &lt;&lt;- _EOF_</span><br><span class="line">&lt;h2&gt;Disk Space Utilization&lt;/h2&gt;</span><br><span class="line">&lt;pre&gt;$(df -h)&lt;/pre&gt;</span><br><span class="line">_EOF_</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">report_home_space () &#123;</span><br><span class="line">cat &lt;&lt;- _EOF_</span><br><span class="line">&lt;h2&gt;Home Space Utilization&lt;/h2&gt;</span><br><span class="line">&lt;pre&gt;$(sudo du -sh /home/*)&lt;/pre&gt;</span><br><span class="line">_EOF_</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; _EOF_</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;$TITLE&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">   width: 400px;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 align=&quot;center&quot;&gt;$TITLE&lt;/h1&gt;</span><br><span class="line">&lt;p align=&quot;center&quot;&gt;$TIMESTAMP&lt;/p&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(report_uptime)</span></span><br><span class="line">&lt;div align=&quot;left&quot; class=&quot;box&quot;&gt;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(report_disk_space)</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(report_home_space)</span></span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">_EOF_</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211241157392.png" alt></p><p>至此，我们成功启动我们编写的 shell 脚本文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea使用内嵌的Tomcat获取前端用户信息</title>
      <link href="/2022/09/22/idea%E4%BD%BF%E7%94%A8%E5%86%85%E5%B5%8C%E7%9A%84Tomcat%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
      <url>/2022/09/22/idea%E4%BD%BF%E7%94%A8%E5%86%85%E5%B5%8C%E7%9A%84Tomcat%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="前后台通讯-前台发送数据到后台"><a class="markdownIt-Anchor" href="#前后台通讯-前台发送数据到后台">#</a> 前后台通讯 - 前台发送数据到后台</h2><ul><li><h5 id="工具idea社区版"><a class="markdownIt-Anchor" href="#工具idea社区版">#</a> 工具：idea 社区版</h5></li><li><h5 id="环境没有配置的可以参考以下链接"><a class="markdownIt-Anchor" href="#环境没有配置的可以参考以下链接">#</a> 环境：(没有配置的可以参考以下链接)</h5><ul><li><p><a href="https://blog.csdn.net/SmartDemo/article/details/104609358?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~Rate-5-104609358-blog-107976316.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~Rate-5-104609358-blog-107976316.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=10">配置 Tomcat</a></p></li><li><p><a href="https://blog.csdn.net/a805814077/article/details/100545928?ops_request_misc=%7B%22request%5Fid%22%3A%22166355246116782425199852%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=166355246116782425199852&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-100545928-null-null.142%5Ev47%5Econtrol,201%5Ev3%5Eadd_ask&amp;utm_term=maven&amp;spm=1018.2226.3001.4187">配置 Maven</a></p></li></ul></li><li><h5 id="介绍在java代码中内嵌的tomcat使用main函数启动-加载html页面后用户输入信息获取后显示在控制台"><a class="markdownIt-Anchor" href="#介绍在java代码中内嵌的tomcat使用main函数启动-加载html页面后用户输入信息获取后显示在控制台">#</a> 介绍：在 java 代码中内嵌的 Tomcat, 使用 main 函数启动。加载 html 页面后，用户输入信息，获取后显示在控制台</h5></li><li><h5 id="步骤"><a class="markdownIt-Anchor" href="#步骤">#</a> 步骤</h5><ul><li><a href="#index1">idea 中建立 Maven 项目</a></li><li><a href="#index2">编写前端页面 html，用户提交信息</a></li><li><a href="#index3">创建 Serlvet 类，并在 main 函数中嵌入 Tomcat 代码</a></li><li><a href="#index4">运行测试类的 main 函数，获取页面信息输入到后端</a></li></ul></li></ul><h3 id="a-idindex1一-idea中建立maven项目a"><a class="markdownIt-Anchor" href="#a-idindex1一-idea中建立maven项目a">#</a> <a id="index1">一. idea 中建立 Maven 项目</a></h3><h4 id="1在idea中配置maven"><a class="markdownIt-Anchor" href="#1在idea中配置maven">#</a> 1. 在 Idea 中配置 maven</h4><ul><li><p>打开 Idea，点击 File，然后点击 Settings，进入设置，或者直接按 Ctrl+Alt+S 进入设置</p><img src="https://img1.imgtp.com/2022/11/24/VJ6n1IS2.png" style="zoom:67%;"> </li><li><p>先在左上角的搜索框输入 maven，找到 maven 后单击，然后在右边的 maven home path 的右边选择你的 maven 安装路径，选择到根目录就好了，然后点击确定，具体步骤看下图：</p><img src="https://img1.imgtp.com/2022/11/24/aFUD6Avx.png" style="zoom: 50%;"> </li><li><p>Local repository 是 maven 的 本地仓库，默认路径是 C:\Users\Administrator.m2\repository，可以使用默认路径也可以在 settings.xml 中配置本地 maven 仓库，看自己需要，一般在 settings.xml 中配置好了这里会自动检测你在 settings.xml 中配置的仓库路径 ，具体步骤如下图：</p><img src="https://img1.imgtp.com/2022/11/24/7VQIZiw9.png" style="zoom: 50%;"> </li></ul><h4 id="2在idea中创建maven项目"><a class="markdownIt-Anchor" href="#2在idea中创建maven项目">#</a> 2. 在 Idea 中创建 maven 项目</h4><ul><li><p>点击 File，选择 New，再点击 Project</p></li><li><p>建立 maven 工程，具体看图，别选错 webapp 了</p><img src="https://img1.imgtp.com/2022/11/24/LMWtQ14t.png" style="zoom:50%;">    </li><li><p>接下来输入各类名称，填完后直接 next 下一步</p></li><li><p>配置 maven 信息，具体操作如下图：</p><img src="https://img1.imgtp.com/2022/11/24/YBKnKIpW.png" style="zoom:50%;"> </li><li><p>添加配置 DarchetypeCatalog=internal，添加原因：每次创建 maven 项目时， IDEA 要使用插件进行创建，这些插件当你创建新的项目时，它每次都会去中央仓库下载，这样使得创建比较慢。所以在创建 maven 项目时，应该让它找本地仓库中的插件进行项目的创建。</p></li></ul><p>​       <code>DarchetypeCatalog=internal</code></p><p>​      <img src="https://img1.imgtp.com/2022/11/24/ByUL6aEy.png" style="zoom:50%;"></p><h4 id="3完善maven-web项目模板"><a class="markdownIt-Anchor" href="#3完善maven-web项目模板">#</a> 3. 完善 maven-web 项目模板</h4><ul><li><p>第一次加载 maven 项目比较慢，等待右下角的进度条加载结束，下面是刚建好的 maven-web 项目模板</p><img src="https://img1.imgtp.com/2022/11/24/iz6pdUI9.png" style="zoom: 67%;">  </li><li><p>上面的项目不完整，不能满足我们的开发需要，所以需要我们手动建设一些文件夹，需要兴建的文件夹如下，以下是 maven 项目的标准目录结构：<br>src/main/java<br>src/main/resources<br>src/test/java<br>src/test/resources<br> 下面来构建目录，在 main 上右击 New-&gt;Directory 新建 java 文件夹和 resources 文件夹<br>在 src 目录上右击 New-&gt;Directory 新建 test 文件夹<br>在 test 目录上右击 New-&gt;Directory 新建 java 和 resources 文件夹<br>下面只演示一个，其余类似</p><img src="https://img1.imgtp.com/2022/11/24/PT072gxN.png" style="zoom: 50%;">  </li><li><p>接下来就是把新建立的文件夹进行关联了，看清楚关联对象，关联错了就得重新关联，这一定不能出错，关联方法如下图。<br>src/main/java 关联为 Sources Root<br>src/main/resources 关联为 Resources Root<br>src/test/java 关联为 Test Sources Root<br>src/test/resources 关联为 Test Resources Root</p><img src="https://img1.imgtp.com/2022/11/24/OiW1gPj5.png" style="zoom:50%;">  </li><li><p>以下是关联之后完整的 maven-web 项目的目录，配置完成</p><img src="https://img1.imgtp.com/2022/11/24/kiQfsXui.png" style="zoom: 67%;">  </li></ul><h3 id="a-idindex2二-编写前端页面html用户提交信息a"><a class="markdownIt-Anchor" href="#a-idindex2二-编写前端页面html用户提交信息a">#</a> <a id="index2">二。编写前端页面 html，用户提交信息</a></h3><ul><li><p>acion 对应创建的 Serlvet 类，method 使用 doPost 方法（见第三部分 java 代码）</p></li><li><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">color:green;size</span>=<span class="string">&quot;20&quot;</span>&gt;</span>userinfo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;LoginServlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        hometown: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hometown&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Login&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>效果如图：（用户输入信息后点击 Login 登录）</p></li></ul><img src="https://img1.imgtp.com/2022/11/24/TEajWvJF.png" style="zoom: 67%;">   <h3 id="a-idindex3三-创建serlvet类并在main函数中嵌入tomcat代码a"><a class="markdownIt-Anchor" href="#a-idindex3三-创建serlvet类并在main函数中嵌入tomcat代码a">#</a> <a id="index3">三。创建 Serlvet 类，并在 main 函数中嵌入 Tomcat 代码</a></h3><h4 id="1-在pomxml中导入servlet依赖注意代码放在dependencysdependencys之间"><a class="markdownIt-Anchor" href="#1-在pomxml中导入servlet依赖注意代码放在dependencysdependencys之间">#</a> 1. 在 pom.xml 中导入 Servlet 依赖，注意代码放在 &lt;dependencys&gt;&lt;/dependencys &gt; 之间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--加入servlet依赖（servlet的jar）--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">4.0</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;!--jsp的依赖（jsp相关的jar加进来）--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">2.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2-创建serlvet类loginserlvet实现httpservlet接口"><a class="markdownIt-Anchor" href="#2-创建serlvet类loginserlvet实现httpservlet接口">#</a> 2. 创建 Serlvet 类（LoginSerlvet）实现 HttpServlet 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;  <span class="comment">//注意要导入Serlvet依赖</span></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>); <span class="comment">//对应html代码中input的name属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hometown</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;hometown&quot;</span>);</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out=resp.getWriter();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span>+username);</span><br><span class="line">        System.out.println(<span class="string">&quot;籍贯：&quot;</span>+hometown);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在pomxml中导入tomcat依赖"><a class="markdownIt-Anchor" href="#3-在pomxml中导入tomcat依赖">#</a> 3. 在 pom.xml 中导入 Tomcat 依赖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.tomcat/tomcat-servlet-api --&gt;</span></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">9.0</span><span class="number">.12</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.tomcat/tomcat-catalina --&gt;</span></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">9.0</span><span class="number">.46</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="4-建立一个测试类在main函数中嵌入tomcat代码"><a class="markdownIt-Anchor" href="#4-建立一个测试类在main函数中嵌入tomcat代码">#</a> 4. 建立一个测试类，在 main 函数中嵌入 Tomcat 代码</h4><ul><li>使用 main 函数启动，默认加载 webapp 下的 index.jsp</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.catalina.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.WebResourceRoot;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.startup.Tomcat;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.webresources.DirResourceSet;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.webresources.StandardRoot;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Login</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">        tomcat.setPort(Integer.getInteger(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        tomcat.getConnector();</span><br><span class="line">        <span class="comment">// 创建 WebApp</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/main/webapp&quot;</span>).getAbsolutePath());</span><br><span class="line">        <span class="type">WebResourceRoot</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardRoot</span>(context);</span><br><span class="line">        resources.addPreResources(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DirResourceSet</span>(resources, <span class="string">&quot;/WEB-INF/classes&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target/classes&quot;</span>).getAbsolutePath(), <span class="string">&quot;/&quot;</span>));</span><br><span class="line">        context.setResources(resources);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-配置webxml文件使tomcat启动时加载我们写好的html文件配置tomcat映射路径使serlvet类能获取页面信息"><a class="markdownIt-Anchor" href="#5-配置webxml文件使tomcat启动时加载我们写好的html文件配置tomcat映射路径使serlvet类能获取页面信息">#</a> 5. 配置 web.xml 文件，使 tomcat 启动时加载我们写好的 html 文件，配置 Tomcat 映射路径，使 Serlvet 类能获取页面信息。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;  <span class="comment">//与创建的Serlvet类同名</span></span><br><span class="line">    &lt;servlet-class&gt;LoginServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/LoginServlet&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line">  &lt;welcome-file-list&gt;</span><br><span class="line">    &lt;welcome-file&gt;userinfo.html&lt;/welcome-file&gt;  <span class="comment">//加载我们编写的html文件</span></span><br><span class="line">  &lt;/welcome-file-list&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h3 id="a-idindex4四-运行测试类的main函数获取页面信息输入到后端a"><a class="markdownIt-Anchor" href="#a-idindex4四-运行测试类的main函数获取页面信息输入到后端a">#</a> <a id="index4">四。运行测试类的 main 函数，获取页面信息输入到后端</a></h3><ul><li><p>运行 main 函数，在地址栏输入 locathost:8080/userinfo.html（自己编写的 html 文件）访问前端页面，输入信息，点击 Login 登录。</p><img src="https://img1.imgtp.com/2022/11/24/pQxzk1EX.png" style="zoom:67%;"> </li><li><p>可以看到控制台获取前端数据并输出：</p><img src="https://img1.imgtp.com/2022/11/24/y9Qp7yWe.png" style="zoom:67%;"> <p>至此我们成功获得前端数据并输出</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows XP驱动编程</title>
      <link href="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简单操作系统驱动及安全"><a class="markdownIt-Anchor" href="#简单操作系统驱动及安全">#</a> 简单操作系统驱动及安全</h1><h1 id="一-配置和环境"><a class="markdownIt-Anchor" href="#一-配置和环境">#</a> 一。配置和环境</h1><ul><li><p>系统 windows XP</p></li><li><p>安装 Windows SDK &amp; DDK</p><ul><li>下载链接：<a href="https://winworldpc.com/product/windows-sdk-ddk/xp-nt-51">Windows  DDK</a></li></ul></li><li><p>下载 DriverMonitor.exe（将文件加载到内核）</p></li><li><p>下载 DirverView.exe（观察驱动运行结果）</p></li></ul><h1 id="二-windows-xp平台下的驱动框架进行说明"><a class="markdownIt-Anchor" href="#二-windows-xp平台下的驱动框架进行说明">#</a> 二. Windows XP 平台下的驱动框架进行说明。</h1><h3 id="1-windows-xp驱动框架"><a class="markdownIt-Anchor" href="#1-windows-xp驱动框架">#</a> 1. Windows XP 驱动框架。</h3><p>Windows XP 驱动不同于普通的 C 应用态程序。C 应用态程序的入口是 main 函数，但是驱动中没有 main 函数，Windows XP 驱动入口函数称为 “DriverEntry” 的函数。在驱动加载后，第一个运行的就是 DriverEntry 函数，因此，所有需要初始化的工作都是在 DriverEntry 函数当中完成的。接下来，在初始化完成之后，DriverEntry（通过调用其他的功能函数）将控制权交给功能函数以完成必要的驱动功能。最后，当驱动工作完成之后，必须退出以释放内核空间，这是通过调用 “驱动退出函数” 实现的。与 Windows XP 驱动一定有一个固定的、称为 “DriverEntry” 的入口函数不同，“驱动退出函数” 的名称是不定的，具体名称是什么，由 “DriverEntry” 中的 “driver-&gt;DriverUnload” 语句指定函数名。具体到本实验的例子（参见如下 Encryption.c 源码），有语句 “driver-&gt;DriverUnload = DriverUnload;”，因此在本例中，驱动的退出函数名为 “DriverUnload”。</p><p>综上，Windows XP 下的驱动框架部分需要掌握以下几点：</p><ul><li><p>首先，驱动的入口函数称为 “DriverEntry”，在 “DriverEntry” 中完成驱动的所有初始化工作；</p></li><li><p>之后，“DriverEntry”（通过调用其他功能函数）将控制权交给其他功能函数以完成驱动所需的功能。这个过程和用户态 C 语言的子函数调用是类似的；</p></li><li><p>最后，在 “DriverEntry” 使用 “driver-&gt;DriverUnload = XXXX;” 语句指定驱动退出函数。上例中 XXXX 就是驱动退出函数的函数名，由用户进行编写后指定。当驱动程序退出时，会自动调用驱动退出函数以完成必要的终止和回收工作。</p></li></ul><h3 id="2-windows驱动编译"><a class="markdownIt-Anchor" href="#2-windows驱动编译">#</a> 2. Windows 驱动编译。</h3><p>驱动的编译可以采用 DDK 环境，也可以采用 VC 环境。本次实验采用 DDK 环境进行编译（感兴趣的同学可以搜索如何以 VC6.0 环境编译驱动。两者编译的结果是一样的，没有差别）。利用 DDK 环境编译驱动的具体过程如下：</p><p>首先在源程序的相同目录下创建两个文本文件 makefile 和 Sources。这两个文本文件描述了 DDK 驱动程序的源文件、用到的 lib 文件、inlcude 路径名以及编译输出的目录和文件名等信息，具体示例如下。</p><p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image002.jpg" alt="img"></p><p>表 1 当中，第 1 行说明驱动的名称为 Encrytion（驱动名根据需要修改）；第 2 行指明此驱动的类型为 NT 型驱动；第 3 行设置编译输出目录；第 4 行指定编译原文件名为 Encryption.c（驱动源文件根据需要修改）。</p><p>Makefile 文件内容如下：</p><p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image004.jpg" alt="img"></p><p>编写完这两个脚本之后，在 Windows 的开始菜单中选择 “Windows XP Checked Build Environment” 编译环境，启动运行，进入到 cmd 命令界面。实验时选择 Checked 版本，而不是 Free 版本，两者的区别类似于 Win32 程序开发的 Debug 版本和 Release 版本。</p><p>最后，在进入命令行方式的 cmd 窗口之后，用 cd 命令进入需要编译的目录，然后输入 “build” 命令，DDK 的编译环境就会自动调用编译器进行编译。如果编译出错，对应修改源文件即可；编译成功之后，会在 obj 目录中生成 Encryption.sys 文件。一旦成功生成了.sys 文件，即可使用附带的 instdrv.exe 将驱动 Encryption.sys 加载到内核运行。</p><p>综上，Windows XP 驱动编译需要掌握如下几点：</p><ul><li><p>Windows XP 驱动可以采用 DDK 环境编译，也可以采用 VC 环境编译。两者的编译结果是一样的。</p></li><li><p>采用 DDK 环境编译时，需要在驱动程序所在的目录下创建 makefile 和 Sources 文件，具体的写法参见表 1。</p></li><li><p>l 驱动编译的结果是.sys 文件。</p></li></ul><h3 id="3-windows驱动安装与运行"><a class="markdownIt-Anchor" href="#3-windows驱动安装与运行">#</a> 3. Windows 驱动安装与运行。</h3><p>Windows 驱动编译生成.sys 文件。.sys 文件是不能直接运行的，必须要插入到内核当中。本实验当中，采用 DriverMonitor.exe 工具将其插入（当然选用其他工具也可以）。其步骤如下：</p><ul><li><p>首先下载 DriverMonitor.exe 文件并安装到本机。</p></li><li><p>运行 DriverMonitor.exe。点击”Edit“，添加文件。</p></li><li><p>打开编译得到的.sys 文件。</p></li></ul><h3 id="4-驱动信息查看"><a class="markdownIt-Anchor" href="#4-驱动信息查看">#</a> 4. 驱动信息查看。</h3><p>以上完成了驱动的加载，查看驱动运行信息（驱动中可以使用 DbgPrint 来打印一些信息，方便调试）可以采用 DbgView.exe 工具，运行之后，勾选 “Capture Kernel” 捕获内核信息即可。</p><p>以下是源码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ENCRYPTION</span></span><br><span class="line"><span class="comment">//#define DECRYPTION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ntddk.h&gt;</span></span></span><br><span class="line">NTSTATUS <span class="title function_">Encryption</span><span class="params">()</span>;</span><br><span class="line">VOID <span class="title function_">EnCode</span><span class="params">(PUCHAR pBuffer, SIZE_T bufferSize)</span>;</span><br><span class="line">VOID <span class="title function_">DeCode</span><span class="params">(PUCHAR pBuffer, SIZE_T bufferSize)</span>;</span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Driver Entry</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hfile;</span><br><span class="line">  PUCHAR pBuffer;</span><br><span class="line">  NTSTATUS ntStatus;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#if DBG</span></span><br><span class="line"><span class="comment">  _asm int 3</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">    内核打印需要使用DbgPrint函数。注意在内核中是不能使用应用态的库函数的，</span></span><br><span class="line"><span class="comment">    因此，这里不能用printf，而只能使用内核专有的DbgPrint。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  DbgPrint(<span class="string">&quot;Entering OS Kernel!\r\n&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  DbgPrint(&quot;The Driver name is: %wZ\n&quot;, driver-&gt;DriverName);</span></span><br><span class="line"><span class="comment">  DbgPrint(&quot;The Driver size is: %ld\n&quot;, driver-&gt;DriverSize);</span></span><br><span class="line"><span class="comment">  DbgPrint(&quot;The Driver start address: %x\n&quot;, driver-&gt;DriverStart);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ntStatus = Encryption();</span><br><span class="line">  <span class="comment">//Driver Exit</span></span><br><span class="line">  driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">  <span class="keyword">return</span> ntStatus;</span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">  DbgPrint(<span class="string">&quot;Leaving OS Kernel! Bye, Good luck!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件读写操作</span></span><br><span class="line">NTSTATUS <span class="title function_">Encryption</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hfile;</span><br><span class="line">  OBJECT_ATTRIBUTES  objectAttributes;</span><br><span class="line">  IO_STATUS_BLOCK   ioStatus;</span><br><span class="line">  UNICODE_STRING   logFileUnicodeString;</span><br><span class="line">  NTSTATUS    ntStatus;</span><br><span class="line">  FILE_STANDARD_INFORMATION fsi;</span><br><span class="line">  PUCHAR pBuffer, tempPBuffer;</span><br><span class="line">  SIZE_T fileSize;</span><br><span class="line">  WCHAR *file2En = <span class="string">L&quot;\\??\\D:\\TEDP_DEV\\TEST\\1.doc&quot;</span>; <span class="comment">//读取此文件内容，之后对其加密</span></span><br><span class="line">  WCHAR *enFile = <span class="string">L&quot;\\??\\D:\\TEDP_DEV\\TEST\\Encrypted.doc&quot;</span>;   <span class="comment">//加密以后写入到此文件</span></span><br><span class="line">  <span class="comment">//初始化要读取文件的UNICODE_STRING字符串</span></span><br><span class="line">  RtlInitUnicodeString(&amp;logFileUnicodeString, file2En);</span><br><span class="line">  <span class="comment">//RtlInitUnicodeString(&amp;logFileUnicodeString, &amp;fileName);</span></span><br><span class="line">  <span class="comment">//初始化要读取文件的objectAttributes</span></span><br><span class="line">  InitializeObjectAttributes(&amp;objectAttributes,</span><br><span class="line">              &amp;logFileUnicodeString,</span><br><span class="line">              OBJ_CASE_INSENSITIVE,</span><br><span class="line">              <span class="literal">NULL</span>,</span><br><span class="line">              <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//打开要读取的文件</span></span><br><span class="line">  ntStatus = ZwCreateFile(&amp;hfile,</span><br><span class="line">             GENERIC_READ,</span><br><span class="line">            &amp;objectAttributes,</span><br><span class="line">            &amp;ioStatus,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">            FILE_SHARE_READ,</span><br><span class="line">            FILE_OPEN,</span><br><span class="line">            FILE_SYNCHRONOUS_IO_NONALERT,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!NT_SUCCESS(ntStatus))</span><br><span class="line">  &#123;</span><br><span class="line">   KdPrint((<span class="string">&quot;Open read-file failed!\n&quot;</span>));</span><br><span class="line">   <span class="keyword">return</span> ntStatus;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   KdPrint((<span class="string">&quot;Open read-file successfully!\n&quot;</span>));</span><br><span class="line">  <span class="comment">//查询要读取文件的相关信息，以便读取</span></span><br><span class="line">  ntStatus = ZwQueryInformationFile(hfile,</span><br><span class="line">                 &amp;ioStatus,</span><br><span class="line">                 &amp;fsi,</span><br><span class="line">                 <span class="keyword">sizeof</span>(FILE_STANDARD_INFORMATION),</span><br><span class="line">                 FileStandardInformation);</span><br><span class="line">  <span class="keyword">if</span> (!NT_SUCCESS(ntStatus))</span><br><span class="line">  &#123;</span><br><span class="line">   KdPrint((<span class="string">&quot;Query of read-file failed!\n&quot;</span>));</span><br><span class="line">   <span class="keyword">return</span> ntStatus;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//本来fsi.EndofFile.QuadPart是LONGLONG类型，但是，一个文件不会有64位大。32位已有4G，这里转为SIZE_T</span></span><br><span class="line">  fileSize = (SIZE_T)fsi.EndOfFile.QuadPart; </span><br><span class="line">  KdPrint((<span class="string">&quot;Totally %ld bytes will be read\n&quot;</span>, fileSize));</span><br><span class="line">  <span class="comment">//为读取的文件分配缓冲区，在本程序中该缓冲区被释放</span></span><br><span class="line">  pBuffer = (PUCHAR)ExAllocatePoolWithTag(PagedPool, fileSize, <span class="string">&#x27;Tag1&#x27;</span>);  </span><br><span class="line">  <span class="keyword">if</span> (pBuffer == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   KdPrint((<span class="string">&quot;Allocation memory for reading file failed!\n&quot;</span>));</span><br><span class="line">   <span class="keyword">return</span> ntStatus; <span class="comment">//?</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   tempPBuffer = pBuffer;</span><br><span class="line">  <span class="comment">//读取文件内容</span></span><br><span class="line">  ntStatus = ZwReadFile(hfile,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            &amp;ioStatus,</span><br><span class="line">            pBuffer,</span><br><span class="line">            fileSize,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!NT_SUCCESS(ntStatus))</span><br><span class="line">  &#123;</span><br><span class="line">   KdPrint((<span class="string">&quot;Open read-file failed!\n&quot;</span>));</span><br><span class="line">   ZwClose(hfile);</span><br><span class="line">   ExFreePool(pBuffer);</span><br><span class="line">   <span class="keyword">return</span> ntStatus;</span><br><span class="line">  &#125;</span><br><span class="line">  KdPrint((<span class="string">&quot;Finally %ld bytes were read\n&quot;</span>, ioStatus.Information));</span><br><span class="line">  <span class="comment">//关闭被读取的文件</span></span><br><span class="line">  ZwClose(hfile);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//写入加密文件</span></span><br><span class="line">  <span class="comment">//初始化加密文件的UNICODE_STRING字符串</span></span><br><span class="line">  RtlInitUnicodeString(&amp;logFileUnicodeString, enFile);</span><br><span class="line">  <span class="comment">//RtlInitUnicodeString(&amp;logFileUnicodeString, &amp;fileName);</span></span><br><span class="line">  <span class="comment">//初始化objectAttributes</span></span><br><span class="line">  InitializeObjectAttributes(&amp;objectAttributes,</span><br><span class="line">              &amp;logFileUnicodeString,</span><br><span class="line">              OBJ_CASE_INSENSITIVE,</span><br><span class="line">              <span class="literal">NULL</span>,</span><br><span class="line">              <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//打开写文件以便写</span></span><br><span class="line">  ntStatus = ZwCreateFile(&amp;hfile,</span><br><span class="line">            GENERIC_WRITE,     <span class="comment">//准备写文件</span></span><br><span class="line">            &amp;objectAttributes,</span><br><span class="line">            &amp;ioStatus,</span><br><span class="line">            <span class="literal">NULL</span>,       <span class="comment">//没有指定初始化分配的文件空间大小</span></span><br><span class="line">            FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">            FILE_SHARE_READ,  <span class="comment">//其他进程不能写该文件</span></span><br><span class="line">            FILE_OPEN_IF,    <span class="comment">//创建文件，如果文件已存在的话，则清空打开</span></span><br><span class="line">            FILE_SYNCHRONOUS_IO_NONALERT,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!NT_SUCCESS(ntStatus))</span><br><span class="line">  &#123;</span><br><span class="line">   KdPrint((<span class="string">&quot;Open write-file failed!\n&quot;</span>));</span><br><span class="line">   ExFreePool(pBuffer);</span><br><span class="line">   <span class="keyword">return</span> ntStatus;</span><br><span class="line">  &#125;</span><br><span class="line">  KdPrint((<span class="string">&quot;Create file successfully!\n&quot;</span>));</span><br><span class="line">  <span class="comment">//对pBuffer的内容进行加密</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENCRYPTION</span></span><br><span class="line">  EnCode(pBuffer, fileSize);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">  <span class="comment">//开始写入文件</span></span><br><span class="line">  ntStatus = ZwWriteFile(hfile,</span><br><span class="line">             <span class="literal">NULL</span>,</span><br><span class="line">             <span class="literal">NULL</span>,</span><br><span class="line">             <span class="literal">NULL</span>,</span><br><span class="line">             &amp;ioStatus,</span><br><span class="line">             pBuffer,</span><br><span class="line">             fileSize,</span><br><span class="line">             <span class="literal">NULL</span>,</span><br><span class="line">             <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (!NT_SUCCESS(ntStatus))</span><br><span class="line">  &#123;</span><br><span class="line">   KdPrint((<span class="string">&quot;Write to write-file failed!\n&quot;</span>));</span><br><span class="line">   ExFreePool(pBuffer);      </span><br><span class="line">   ZwClose(hfile);</span><br><span class="line">   <span class="keyword">return</span> ntStatus;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   KdPrint((<span class="string">&quot;Write to write-file successfully!\n&quot;</span>));</span><br><span class="line">   ExFreePool(pBuffer);</span><br><span class="line">   ZwClose(hfile);</span><br><span class="line">   <span class="keyword">return</span> ntStatus;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加密操作。需要替换为DES加密函数</span></span><br><span class="line">VOID <span class="title function_">EnCode</span><span class="params">(PUCHAR pBuffer, SIZE_T bufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(index++ != bufferSize)</span><br><span class="line">  &#123;</span><br><span class="line">   *pBuffer ^= <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">   pBuffer++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解密操作。需要替换为DES解密函数</span></span><br><span class="line">VOID <span class="title function_">DeCode</span><span class="params">(PUCHAR pBuffer, SIZE_T bufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(index++ != bufferSize)</span><br><span class="line">  &#123;</span><br><span class="line">   *pBuffer ^= <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">   pBuffer++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1将上述驱动编译成功"><a class="markdownIt-Anchor" href="#1将上述驱动编译成功">#</a> （1）将上述驱动编译成功。</h4><p>使用 Windows XP x86 Checked Build Enviroment 进行编译：</p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image006.jpg" alt="img" style="zoom:80%;"> <p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image008.jpg" alt="img"></p><p>编译后产生的 sys 文件（系统文件）：</p><p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image010.jpg" alt="img"></p><h4 id="2将编译成功的驱动插入到内核运行并观察运行结果"><a class="markdownIt-Anchor" href="#2将编译成功的驱动插入到内核运行并观察运行结果">#</a> （2）将编译成功的驱动插入到内核运行，并观察运行结果。</h4><p>使用 DriverMonitor.exe 将 sys 文件加载到内核运行：</p><p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image012.jpg" alt="img"></p><p>然后使用 DirverView.exe 观察驱动运行结果：</p><p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image014.jpg" alt="img"></p><p>原文件内容：</p><p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image016.jpg" alt="img"></p><p>加密后的文件：</p><p><img src="/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/clip_image018.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信</title>
      <link href="/2022/09/18/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/09/18/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一-进程间通信机制说明"><a class="markdownIt-Anchor" href="#一-进程间通信机制说明">#</a> 一、   进程间通信机制说明</h1><p>linux 下多个进程间的通信机制叫做 IPC，它是多个进程之间相互沟通的一种方法。在 linux 下有多种进程间通信的方法：半双工管道、命名管道、消息队列、信号、信号量、共享内存、内存映射文件，套接字等等。</p><h1 id="二-进程间通信方法说明"><a class="markdownIt-Anchor" href="#二-进程间通信方法说明">#</a> 二、   进程间通信方法说明</h1><h2 id="21-半双工管道方法说明"><a class="markdownIt-Anchor" href="#21-半双工管道方法说明">#</a> 2.1 半双工管道方法说明</h2><p>（1）管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用 fork 后，这个管道就能在父子进程间使用了。</p><p>（2）管道通过 pipe (int fd [2]) 函数创建，参数 fd [0] 为读而打开，fd [1] 为写而打开。fd [1] 的输出是 fd [0] 的输入。简单来说，当父进程打开 fd [1] 关闭 fd [0], 就可以向管道写入文件，而子进程打开 fd [0] 关闭 fd [1], 可以从管道中读取文件。</p><h2 id="22-命名管道方法说明"><a class="markdownIt-Anchor" href="#22-命名管道方法说明">#</a> 2.2 命名管道方法说明</h2><p>命名管道又称 FIFO, 它是一种特殊类型的文件，它在系统中以文件形式存在。未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是，通过 FIFO, 不相关的进程也能交换数据。我们可以使用 mkfifo 或者 mkfifoat 创建 FIFO, 然后用 opne 来打开它。如果命名管道 FIFO 打开时设置了读权限，则读进程将一直阻塞，一直到其他进程打开该 FIFO 并向管道写入数据。</p><h2 id="23-消息队列方法说明"><a class="markdownIt-Anchor" href="#23-消息队列方法说明">#</a> 2.3 消息队列方法说明</h2><p>消息队列是消息的链接表，储存在内核中，由消息队列标识符标识。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。 msgget 创建一个新队列或打开一个存在的队列；msgsnd 向队列末端添加一条新消息；msgrcv 从队列中取消息， 取消息是不一定遵循先进先出的， 也可以按消息的类型字段取消息。</p><h2 id="24-共享储存方法说明"><a class="markdownIt-Anchor" href="#24-共享储存方法说明">#</a> 2.4 共享储存方法说明</h2><p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过内存读读出其中的消息内容，从而实现了进程间的通信。通过 shmget 创建一个共享内存段，并获得一个进程标识符。然后通过 shmat 将其连接到它的地址空间，shmat 的返回值是该段所连接的实际地址。可以通过指针指向该地址对其中内容进行操作。</p><h1 id="三-同步互斥方法实现"><a class="markdownIt-Anchor" href="#三-同步互斥方法实现">#</a> 三、   同步互斥方法实现</h1><h2 id="31-半双工管道方法实现"><a class="markdownIt-Anchor" href="#31-半双工管道方法实现">#</a> 3.1 半双工管道方法实现</h2><h3 id="311-半双工管道示例代码"><a class="markdownIt-Anchor" href="#311-半双工管道示例代码">#</a> 3.1.1 半双工管道示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_END 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_END 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> write_msg[BUFFER_SIZE]=<span class="string">&quot;Greetings\n&quot;</span>;<span class="comment">//要写入的信息</span></span><br><span class="line">  <span class="type">char</span> read_msg[BUFFER_SIZE];<span class="comment">//存放读取文件</span></span><br><span class="line">  <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">if</span>(pipe(fd)==<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Pipe failed&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pid=fork();</span><br><span class="line">  <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Fork failed&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程，向管道写入信息</span></span><br><span class="line">  &#123;</span><br><span class="line">   close(fd[READ_END]);<span class="comment">//关闭读出端</span></span><br><span class="line">   <span class="comment">/*从write_msg中写入数据到fd[WRUTE_END]中，并指定写入数据长度*/</span></span><br><span class="line">   write(fd[WRITE_END],write_msg,<span class="built_in">strlen</span>(write_msg)+<span class="number">1</span>);</span><br><span class="line">   close(fd[WRITE_END]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//子进程，向管道读取信息</span></span><br><span class="line">  &#123;</span><br><span class="line">   close(fd[WRITE_END]); <span class="comment">//关闭写入端</span></span><br><span class="line">   <span class="comment">/*从fd[READ_END]中读取数据到read_msg中*/</span></span><br><span class="line">   read(fd[READ_END],read_msg,BUFFER_SIZE);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;read:%s&quot;</span>,read_msg);</span><br><span class="line">   close(fd[READ_END]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译及运行结果：</p><p><img src="http://img.sunsetsy.top/img/202403061544241.png" alt></p><h3 id="312半双工管道关键代码说明"><a class="markdownIt-Anchor" href="#312半双工管道关键代码说明">#</a> 3.1.2 半双工管道关键代码说明</h3><p>（1）父进程关闭读出端，通过 write 函数从 write_msg 中写入数据到 fd [WRUTE_END] 中</p><p>close(fd[READ_END]);</p><p>write(fd[WRITE_END],write_msg,strlen(write_msg)+1);</p><p>（2）子进程关闭写入端，通过 read 函数从 fd [READ_END] 中读取数据到 read_msg 中，然后输出到标标准输出。</p><p>close(fd[WRITE_END]);</p><p>read(fd[READ_END],read_msg,BUFFER_SIZE);</p><h2 id="32-命名管道方法实现"><a class="markdownIt-Anchor" href="#32-命名管道方法实现">#</a> 3.2 命名管道方法实现</h2><h3 id="321-命名管道示例代码"><a class="markdownIt-Anchor" href="#321-命名管道示例代码">#</a> 3.2.1 命名管道示例代码</h3><h5 id="服务端代码"><a class="markdownIt-Anchor" href="#服务端代码">#</a> 服务端代码：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;MYFIFO&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp;<span class="comment">//文件指针</span></span><br><span class="line">  <span class="type">char</span> readbuf[<span class="number">80</span>];</span><br><span class="line">  <span class="comment">/*创建命名管道MYFIFO*/</span></span><br><span class="line">  mkfifo(<span class="string">&quot;MYFIFO&quot;</span>,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">/*打开命名管道*/</span></span><br><span class="line">   <span class="keyword">if</span>((fp=fopen(FIFO_FILE,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;open fifo failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*从命名管道中读取数据*/</span></span><br><span class="line">   <span class="keyword">if</span>(fgets(readbuf,<span class="number">80</span>,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Received string : %s\n&quot;</span>,readbuf);</span><br><span class="line">      fclose(fp);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(ferror(fp))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read fifo failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端代码"><a class="markdownIt-Anchor" href="#客户端代码">#</a> 客户端代码：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;MYFIFO&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span>(argc&lt;=<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;usage : %s &lt;pathname&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((fp=fopen(FIFO_FILE,<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;open fifo failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;argc;i++)<span class="comment">//读取命名行参数作为输入数据</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">fputs</span>(argv[i],fp)==EOF)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;write fifo error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">fputs</span>(<span class="string">&quot; &quot;</span>,fp)==EOF)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;write fifo error\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先启动客户端，进入阻塞状态等待客户端的输入。</li></ul><p><img src="http://img.sunsetsy.top/img/202403061545016.png" alt></p><ul><li>然后启动客户端，写入数据到管道中。</li></ul><p><img src="http://img.sunsetsy.top/img/202403061545402.png" alt></p><ul><li>服务端从中读取数据，显示到屏幕。</li></ul><p><img src="http://img.sunsetsy.top/img/202403061546163.png" alt></p><h3 id="322-命名管道关键代码说明"><a class="markdownIt-Anchor" href="#322-命名管道关键代码说明">#</a> 3.2.2 命名管道关键代码说明</h3><p>(1) 创建一个命名管道：</p><p>mkfifo(“MYFIFO”,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH);</p><p>参数  S_IWUSR：用户写权限</p><p>​     S_IRUSR：用户读权限</p><p>​     S_IRGRP：用户组读权限</p><p>​     S_IROTH：其他组读权限</p><p>（2）服务端：</p><p>fp 指向以可读形式打开的管道文件，并从中读取数据到 readbuf 中，然后显示到屏幕。</p><p>fp=fopen(FIFO_FILE,“r”)</p><p>fgets(readbuf,80,fp)</p><p>（3）客户端：</p><p>fp 指向以可写形式打开的管道文件，并将命令行参数写入到管道文件中，以便服务端读取。</p><p>fp=fopen(FIFO_FILE,“w”)</p><p>for(i=1;i&lt;argc;i++)</p><p>fputs(argv[i],fp；</p><h2 id="33-消息队列方法实现"><a class="markdownIt-Anchor" href="#33-消息队列方法实现">#</a> 3.3 消息队列方法实现</h2><h3 id="331-消息队列示例代码"><a class="markdownIt-Anchor" href="#331-消息队列示例代码">#</a> 3.3.1 消息队列示例代码</h3><h5 id="发送消息代码"><a class="markdownIt-Anchor" href="#发送消息代码">#</a> 发送消息代码：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/msg.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> my_msg_type;</span><br><span class="line">  <span class="type">char</span> text[BUFSIZ];</span><br><span class="line">&#125;msgbuf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> running=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> msgid;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> msg_to_receive=<span class="number">0</span>;</span><br><span class="line">  msgid=msgget((<span class="type">key_t</span>)<span class="number">1028</span>,<span class="number">0666</span>|IPC_CREAT);<span class="comment">//创建引用标识符为1028的消息队列</span></span><br><span class="line">  <span class="keyword">if</span>(msgid==<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;magget failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(running)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请输入你想写的信息：&quot;</span>);</span><br><span class="line">   fflush(<span class="built_in">stdin</span>);<span class="comment">//过滤掉最后的enter(换行符)</span></span><br><span class="line">   fgets(msgbuf.text,BUFSIZ,<span class="built_in">stdin</span>);</span><br><span class="line">   msgbuf.my_msg_type=<span class="number">1</span>;</span><br><span class="line">   <span class="comment">/*发送消息;第二个参数是一个指向长整数的指针，其后紧接着的是消息数据*/</span></span><br><span class="line">   <span class="keyword">if</span>(msgsnd(msgid,(<span class="type">void</span>*)&amp;msgbuf,BUFSIZ,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;magsnd failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strncmp</span>(msgbuf.text,<span class="string">&quot;end&quot;</span>,<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">      running=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接收消息代码"><a class="markdownIt-Anchor" href="#接收消息代码">#</a> 接收消息代码：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> my_msg_type;</span><br><span class="line">  <span class="type">char</span> text[BUFSIZ];</span><br><span class="line">&#125;msgbuf;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> running=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> msgid;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> msg_to_receive=<span class="number">0</span>;</span><br><span class="line">  msgid=msgget((<span class="type">key_t</span>)<span class="number">1028</span>,<span class="number">0666</span>|IPC_CREAT);<span class="comment">//创建我们想打开的的消息队列</span></span><br><span class="line">  <span class="keyword">if</span>(msgid==<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;magget failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(running)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">/*接受消息，将它赋值到结构体的地址空间*/</span></span><br><span class="line">   <span class="keyword">if</span>(msgrcv(msgid,(<span class="type">void</span>*)&amp;msgbuf,BUFSIZ,msg_to_receive,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;magrcv failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;你写入信息是：%s&quot;</span>,msgbuf.text);</span><br><span class="line">   <span class="comment">/*比较两个字符串，指定长度为3; 即输入end就结束*/</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strncmp</span>(msgbuf.text,<span class="string">&quot;end&quot;</span>,<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">      running=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*msgctl删除队列(cmd参数指定为IPC_RMID)*/</span></span><br><span class="line">  <span class="keyword">if</span>(msgctl(msgid,IPC_RMID,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;msgct(IPC_RMID) failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：发送方发送消息（不需要先运行接受方程序）</p><p><img src="http://img.sunsetsy.top/img/202403061546006.png" alt></p><p>接收方接收消息：</p><p><img src="http://img.sunsetsy.top/img/202403061547587.png" alt></p><h3 id="332-消息队列关键代码说明"><a class="markdownIt-Anchor" href="#332-消息队列关键代码说明">#</a> 3.3.2 消息队列关键代码说明</h3><p>（1）创建消息队列：msgid=msgget ((key_t) 1028,0666|IPC_CREAT)</p><p>(2) 用户从键盘输入数据，并将数据放到消息队列中：</p><p>fgets(msgbuf.text,BUFSIZ,stdin);</p><p>msgsnd(msgid,(void*)&amp;msgbuf,BUFSIZ,0)</p><p>（3）从队列中取用消息，将它赋值到结构体的地址空间：</p><p>msgrcv(msgid,(void*)&amp;msgbuf,BUFSIZ,msg_to_receive,0)</p><p>第四个参数 type 即 msg_to_receive 指定想要哪一种消息。</p><p>type==0 返回队列中的第一个消息</p><p>type&gt;0 返回队列中的消息类型为 type 的第一个消息</p><p>tyoe&lt;0 返回队列中消息类型值小于等于绝对值的消息，如果消息有若干个，则取类型值最小的消息</p><h2 id="34-共享储存方法实现"><a class="markdownIt-Anchor" href="#34-共享储存方法实现">#</a> 3.4 共享储存方法实现</h2><h3 id="341-共享储存示例代码"><a class="markdownIt-Anchor" href="#341-共享储存示例代码">#</a> 3.4.1 共享储存示例代码</h3><h5 id="服务进程"><a class="markdownIt-Anchor" href="#服务进程">#</a> 服务进程：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> shmid;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">char</span> *shmptr,*s;</span><br><span class="line">  <span class="comment">/*创建一个名为&quot;1234&quot;的共享内存,返回值为共享内存的进程标识符*/</span></span><br><span class="line">  <span class="keyword">if</span>((shmid=shmget(<span class="number">1234</span>,<span class="number">256</span>,IPC_CREAT|<span class="number">0666</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;shmget failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*将共享内存附加到自己的地址空间上*/</span></span><br><span class="line">  <span class="keyword">if</span>((shmptr=shmat(shmid,<span class="number">0</span>,<span class="number">0</span>))==(<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*指定参数IPC_RMID，用于删除共享内存*/</span></span><br><span class="line">   shmctl(shmid,IPC_RMID,(<span class="type">void</span>*)shmptr);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;shmat failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  s=shmptr;</span><br><span class="line">  <span class="keyword">for</span>(c=<span class="string">&#x27;a&#x27;</span>;c&lt;=<span class="string">&#x27;z&#x27;</span>;c++)</span><br><span class="line">  &#123;</span><br><span class="line">   *s++=c;</span><br><span class="line">  &#125;</span><br><span class="line">  *s=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(*shmptr!=<span class="string">&#x27;*&#x27;</span>)<span class="comment">//等待客户端读完数据</span></span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">  shmctl(shmid,IPC_RMID,(<span class="type">void</span>*)shmptr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户进程"><a class="markdownIt-Anchor" href="#客户进程">#</a> 客户进程：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> shmid;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">char</span> *shmptr,*s;</span><br><span class="line">  <span class="keyword">if</span>((shmid=shmget(<span class="number">1234</span>,<span class="number">256</span>,<span class="number">0666</span>))&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;shmget failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((shmptr=shmat(shmid,<span class="number">0</span>,<span class="number">0</span>))==(<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   shmctl(shmid,IPC_RMID,(<span class="type">void</span>*)shmptr);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;shmat failed\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(s=shmptr;*s!=<span class="literal">NULL</span>;s++)</span><br><span class="line">   <span class="built_in">putchar</span>(*s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  *shmptr=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务进程开启等待客户读取完数据：</p><p><img src="http://img.sunsetsy.top/img/202403061604240.png" alt></p><p>客户读取数据：</p><p><img src="http://img.sunsetsy.top/img/202403061604683.png" alt></p><p>客户读取完数据之后服务器进程关闭：</p><p><img src="http://img.sunsetsy.top/img/202403061605305.png" alt></p><h3 id="342-共享储存关键代码说明"><a class="markdownIt-Anchor" href="#342-共享储存关键代码说明">#</a> 3.4.2 共享储存关键代码说明</h3><p>服务端进程：创建标识符为 1234 的共享内存，并用 shmprt 指向它返回的实际地址空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shmid=shmget(1234,256,IPC_CREAT|0666)</span><br><span class="line"></span><br><span class="line">shmptr=shmat(shmid,0,0)</span><br></pre></td></tr></table></figure><p>向其中写入数据后等待客户读取完数据并删除该共享内存段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(*shmptr!=&#x27;*&#x27;)//等待客户端读完数据</span><br><span class="line"></span><br><span class="line">   sleep(1);</span><br><span class="line"></span><br><span class="line">shmctl(shmid,IPC_RMID,(void*)shmptr);</span><br></pre></td></tr></table></figure><p>客户端进程：打开该共享内存，并用 shmprt 指向它返回的实际地址空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shmid=shmget(1234,256,0666)</span><br><span class="line"></span><br><span class="line">shmptr=shmat(shmid,0,0)</span><br></pre></td></tr></table></figure><p>然后读取共享内存段里面的内容，并将共享内存里面的内容设置为’*’, 告诉服务进程已经读取完毕</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(s=shmptr;*s!=NULL;s++)</span><br><span class="line"></span><br><span class="line">   putchar(*s);</span><br><span class="line"></span><br><span class="line">   \*shmptr=&#x27;\*&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora图片上传到博客</title>
      <link href="/2022/09/18/Typora%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/09/18/Typora%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 style="color:blue" align="center">使用Typota上传图片到博客的方法</h1><h3 id="一-使用插件hexo-asset-image"><a class="markdownIt-Anchor" href="#一-使用插件hexo-asset-image">#</a> 一。使用插件 hexo-asset-image</h3><h4 id="1-修改配置文件"><a class="markdownIt-Anchor" href="#1-修改配置文件">#</a> 1. 修改配置文件</h4><ul><li>首先修改 blog (存放博客文件的目录) 文件下的_config.yml 文件，设置 post_asset_folder 这个选项为 true,</li></ul><p>目的是在新建文章时会在_psots 文件夹下自动生成一个同名的文件夹，用来存放上传的图片。</p><p><img src="http://img.sunsetsy.top/img/202403061508855.png" alt="image-20220918151528539"></p><h4 id="2-设置typora的图像配置"><a class="markdownIt-Anchor" href="#2-设置typora的图像配置">#</a> 2. 设置 Typora 的图像配置</h4><ul><li filename>设置图像复制到指定路径，文件地址：./$</li></ul><p><img src="http://img.sunsetsy.top/img/202403061508824.png" alt="image-20220918151816062"></p><h4 id="3-安装hexo-asset-image插件"><a class="markdownIt-Anchor" href="#3-安装hexo-asset-image插件">#</a> 3. 安装 hexo-asset-image 插件</h4><ul><li><p style="color:red">注意 不要使用npm install hexo-asset-image --save这个命令安装,版本号不对,上传图片路径会有问题，使用以下命令</p></li><li><p>进入 blog 目录下，打开 Git push, 输入命令：</p><p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p></li><li><p>或者下载 hexo-asset-image-for-hexo5 插件：</p><p><code>npm install hexo-asset-image-for-hexo5 --save</code></p><p>插件地址：<a href="https://www.npmjs.com/package/hexo-asset-image-for-hexo5">hexo-asset-image-for-hexo5</a></p></li></ul><h4 id="4-最后便可在typora中插入图片上传到博客显示"><a class="markdownIt-Anchor" href="#4-最后便可在typora中插入图片上传到博客显示">#</a> 4. 最后便可在 typora 中插入图片上传到博客显示</h4><h3 id="二-使用picgo-github-搭建个人图床工具"><a class="markdownIt-Anchor" href="#二-使用picgo-github-搭建个人图床工具">#</a> 二。使用 PicGo + GitHub 搭建个人图床工具</h3><h3 id="1github-仓库设置"><a class="markdownIt-Anchor" href="#1github-仓库设置">#</a> 1.GitHub 仓库设置</h3><h4 id="流程新建-public-仓库-创建-token-复制-token-备用"><a class="markdownIt-Anchor" href="#流程新建-public-仓库-创建-token-复制-token-备用">#</a>  <code>流程：新建 public 仓库 -&gt; 创建 token -&gt; 复制 token 备用</code></h4><h4 id="11-新建仓库"><a class="markdownIt-Anchor" href="#11-新建仓库">#</a> 1.1 新建仓库</h4><ul><li><p>点击 git 主页右上角的 + 创建 New repository；</p></li><li><p>填写仓库信息，例如我就创建了一个 cloudimg 的仓库。这里注意，仓库得设置为 Public 因为后面通过客户端访问算是外部访问，因此无法访问 Private ，这样的话图片传上来之后只能存储不能显示。所以要设置为 Public。<br><img src="http://img.sunsetsy.top/img/202403061512344.png" alt></p></li></ul><h4 id="12-创建-token-并复制保存"><a class="markdownIt-Anchor" href="#12-创建-token-并复制保存">#</a> 1.2 创建 token 并复制保存</h4><ol><li>此时仓库已经建立，点击右上角头像，然后进入设置；</li><li>在页面最下找到  <code>Developer settings</code> ，点击进入；</li><li>创建 token；</li></ol><p><img src="/2022/09/18/Typora%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%8D%9A%E5%AE%A2/image-20240306152620221.png" alt="img"></p><ol start="4"><li><p>填 description（也是随心填），勾选复选框 repo ，接着到页面底部  <code>Generate token</code>  就完成了；</p></li><li><p><span>然后复制生成一串字符 token，</span><span style="color:red ">这个 token 只出现一次，所以要保存一下。(一定要记好)</span></p></li></ol><h3 id="2-picgo-客户端配置"><a class="markdownIt-Anchor" href="#2-picgo-客户端配置">#</a> 2. PicGo 客户端配置</h3><h4 id="21-下载安装"><a class="markdownIt-Anchor" href="#21-下载安装">#</a> 2.1 下载 &amp; 安装</h4><ul><li>PicGo （下载最新版就行）是一个开源的图床工具。可以到 git 上下载。<ul><li>下载地址：<a href="https://github.com/Molunerfinn/PicGo">Picgo</a></li></ul></li></ul><h4 id="22-配置"><a class="markdownIt-Anchor" href="#22-配置">#</a> 2.2 配置</h4><ul><li><p>图床配置，设置 Githu 图床</p><p><img src="http://img.sunsetsy.top/img/202403061527105.png" alt="image-20220918155848321"></p></li><li><p>设置监听端口为 36677（不是的话要修改为 36677）</p><p><img src="http://img.sunsetsy.top/img/202403061528467.png" alt="image-20220918160023858"></p></li><li><p>最后便可以上传图片了，注意这里要设置为 Github 图床。</p><p><img src="http://img.sunsetsy.top/img/202403061534322.png" alt="image-20220918160337310"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的同步互斥</title>
      <link href="/2022/09/15/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
      <url>/2022/09/15/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一-引起同步互斥问题的原因"><a class="markdownIt-Anchor" href="#一-引起同步互斥问题的原因">#</a> 一、   引起同步互斥问题的原因</h1><p>同步：因为一些任务不是有一个进程实现，而是通过多个进程共同实现，所以这些进程之间按照一定的规则，互相协调合作共同实现某一任务而进行同步。</p><p>互斥：因为在多个程序并发执行时，由于共享系统资源，对于临界资源，多个进程只能进行互斥的访问，即每次只能允许一个进程访问，所以这些进程对于该资源的访问就形成了相互制约的关系。</p><h1 id="二-同步互斥方法说明"><a class="markdownIt-Anchor" href="#二-同步互斥方法说明">#</a> 二、   同步互斥方法说明</h1><h2 id="21-互斥锁同步互斥方法说明"><a class="markdownIt-Anchor" href="#21-互斥锁同步互斥方法说明">#</a> 2.1 互斥锁同步互斥方法说明</h2><p>当多个线程对公共资源进行访问和写入时，加上互斥锁以保证数据不会被多个线程操作时而混乱。下面以简单读，写操作来说明。一个线程从共享的缓冲区中读取操作，另一个线程向缓冲区中写数据，保证不会对共享缓冲区同时读取和写入，对共享缓冲区的访问加上互斥锁实现。通过线程函数 pthread_create () 在主进程中创建两个线程，一个进行读取，另一个进行写入，如果缓冲区为空，那么就向缓冲区中写入数据，并将 buffer_has_sem 设置为 1，让读线程可以读取数据。读线程则先判断缓冲区是否为空，不为空为输出数据。</p><h2 id="22-条件变量同步互斥方法说明"><a class="markdownIt-Anchor" href="#22-条件变量同步互斥方法说明">#</a> 2.2 条件变量同步互斥方法说明</h2><p>条件变量是对互斥锁的补充，它的作用是用于多线程之间关于共享数据状态变化的通信，它允许线程阻塞并等待另一个线程发送的信号。当收到信号时，阻塞的线程就被唤醒并试图锁定与之相关的互斥锁。以哲学家就餐例子说明。哲学家拿到左右的两只筷子就可以开始吃饭，吃完饭放下筷子思考，利用互斥锁和条件变量进行同步互斥。因为对筷子数量的访问属于临界资源访问，所以对 i 号哲学家拿筷子进行上锁，拿完后便开锁。当 i 号哲学家拿不到左右两只筷子时，便通过条件变量开始等待，其他哲学吃完放下筷子后可以发送信号给该哲学家，当他再次发现筷子可用时便开始吃饭。以通信的方式来实现两者的同步互斥。</p><h2 id="23-信号量同步互斥方法说明"><a class="markdownIt-Anchor" href="#23-信号量同步互斥方法说明">#</a> 2.3 信号量同步互斥方法说明</h2><p>信号量是一个用于表示资源数目的整型量 S，它仅能通过两个标准的原子操作 wait (S) 和 signal (S) 来访问，它是具有一个等待队列的计数器，属于临界资源的一种，要获取信号量资源，则对信号量进行 - 1 操作，要释放信号量资源，则对信号量资源进行 + 1 操作。以读者写者问题进行说明。读和写操作不能同时进行。允许多个读者同时读取数据，通过设置 rw_mutex 信号量来实现读写进程的互斥访问，read_cound 来统计读者的数量，mutex 用于对 read_cound 同步互斥的访问。<strong>一旦一个读者获得了读锁，其他的读者也可以获取这个读锁。但是，想要获取写锁的线程，就必须等到所有的读者都结束。</strong></p><h2 id="24-屏障同步互斥方法说明"><a class="markdownIt-Anchor" href="#24-屏障同步互斥方法说明">#</a> 2.4 屏障同步互斥方法说明</h2><p>屏障是用户协调多个线程并行工作的同步机制。当线程到达屏障点时，它不能继续，直到所有其他的线程也已经到这一点。当最后的线程到达屏障点时，所有线程被释放，并且能够恢复并发执行。使用 pthread_barrier_init () 函数对屏障进行初始化，使用 count 参数指定，在允许所有线程继续运行之前，必须到达屏障的线程数目。使用 pthread_barrier_wait () 函数来表明，线程已工作完成，准备等所有其他线程赶上来。以选手评分例子说明。在主线程中创建 3 个子线程，一个求最高分，另一个求最低分，最后一个线程去掉最高分和最低分后求其平均值，该线程在求最后平均分时必须要等到另外两个子线程求出最高分和最低分。求出的最后得分在主线程中输出。</p><h1 id="三-同步互斥方法实现"><a class="markdownIt-Anchor" href="#三-同步互斥方法实现">#</a> 三、   同步互斥方法实现</h1><h2 id="31互斥锁同步互斥方法实现"><a class="markdownIt-Anchor" href="#31互斥锁同步互斥方法实现">#</a> 3.1 互斥锁同步互斥方法实现</h2><h3 id="311-互斥锁同步互斥示例代码"><a class="markdownIt-Anchor" href="#311-互斥锁同步互斥示例代码">#</a> 3.1.1 互斥锁同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];<span class="comment">//定义共享缓冲区</span></span><br><span class="line"><span class="type">int</span> buffer_has_item=<span class="number">0</span>;<span class="comment">//判断缓冲区是否有数据</span></span><br><span class="line"><span class="type">int</span> retflag=FALSE;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readfun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(retflag)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   pthread_mutex_lock(&amp;mutex);<span class="comment">//对读操作进行上锁</span></span><br><span class="line">   <span class="keyword">if</span>(buffer_has_item==<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;reader：%s\n&quot;</span>,buffer);</span><br><span class="line">      buffer_has_item=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_mutex_unlock(&amp;mutex);<span class="comment">//对读操作进行开锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writefun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">5</span>)<span class="comment">//写入5个数据就退出</span></span><br><span class="line">   &#123;</span><br><span class="line">      retflag=TRUE;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_mutex_lock(&amp;mutex);<span class="comment">//对写入操作进行上锁</span></span><br><span class="line">   <span class="keyword">if</span>(buffer_has_item==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;writer：%c\n&quot;</span>,i+’a’);</span><br><span class="line">      <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%c&quot;</span>,i+’a’);</span><br><span class="line">      buffer_has_item=<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_mutex_unlock(&amp;mutex);<span class="comment">//对写入操作进行开锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//定义两个线程ID</span></span><br><span class="line">  <span class="type">pthread_t</span> reader;</span><br><span class="line">  <span class="type">pthread_t</span> writer;</span><br><span class="line">  pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);<span class="comment">//初始化互斥锁 </span></span><br><span class="line">  <span class="comment">//创建两个子线程</span></span><br><span class="line">  pthread_create(&amp;reader,<span class="literal">NULL</span>,(<span class="type">void</span>*)&amp;readfun,<span class="literal">NULL</span>);</span><br><span class="line">  pthread_create(&amp;writer,<span class="literal">NULL</span>,(<span class="type">void</span>*)&amp;writefun,<span class="literal">NULL</span>); </span><br><span class="line">  <span class="comment">//等待两个子线程结束</span></span><br><span class="line">  pthread_join(reader,<span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(writer,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编译后运行"><a class="markdownIt-Anchor" href="#编译后运行">#</a> 编译后运行：</h5><p><img src="http://img.sunsetsy.top/img/202403061501980.png" alt></p><h5 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果">#</a> 运行结果：</h5><p><img src="http://img.sunsetsy.top/img/202403061502751.png" alt></p><h3 id="312-互斥锁同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#312-互斥锁同步互斥关键代码说明">#</a> 3.1.2 互斥锁同步互斥关键代码说明</h3><p>（1）函数说明：</p><p>​pthread_mutex_inti (&amp;mutex,NULL); // 初始化互斥锁</p><p>​pthread_mutex_lock (&amp;mutex); // 上锁</p><p>​pthread_mutex_unlock (&amp;mutex); // 开锁</p><p>​pthread_join (reader,NULL); // 等待写入线程结束</p><p>​pthread_join (writer,NULL);// 等待读取线程结束</p><p>（2）临界区资源 buffer_has_item</p><p>​     if(buffer_has_item==1){</p><p>​     printf(“read：%s\n”,buffer);</p><p>​     buffer_has_item=0;</p><p>​     }</p><p>​     if(buffer_has_item==0){</p><p>​     printf(“write：%c\n”,i+’a’);</p><p>​     sprintf(buffer,&quot;%c&quot;,i+’a’);</p><p>​     buffer_has_item=1;</p><p>​     }</p><h2 id="32互斥锁同步互斥方法实现"><a class="markdownIt-Anchor" href="#32互斥锁同步互斥方法实现">#</a> 3.2 互斥锁同步互斥方法实现</h2><h3 id="321-条件变量同步互斥示例代码"><a class="markdownIt-Anchor" href="#321-条件变量同步互斥示例代码">#</a> 3.2.1 条件变量同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 6</span></span><br><span class="line"><span class="type">int</span> philosopher_num=<span class="number">0</span>;<span class="comment">//定义想吃的哲学家的数量</span></span><br><span class="line"><span class="type">int</span> chopstick[N]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">//初始化筷子数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//定义对拿筷子的互斥访问</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> num;<span class="comment">//定义对philosopher_num的互斥访问</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond_Var;<span class="comment">//定义条件变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pick_forks</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;num);<span class="comment">//对临界资源上锁</span></span><br><span class="line">  philosopher_num++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d号哲学家想吃饭，共有%d个哲学家想吃饭\n&quot;</span>,i,philosopher_num);</span><br><span class="line">  pthread_mutex_unlock(&amp;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">return_forks</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;num);<span class="comment">//对临界资源上锁</span></span><br><span class="line">  philosopher_num--;</span><br><span class="line">  pthread_mutex_unlock(&amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d号哲学家已吃完开始思考\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">philosopher</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i=*(<span class="type">int</span>*)arg;<span class="comment">//哲学家编号</span></span><br><span class="line">  pick_forks(i);</span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">while</span>(chopstick[i]==<span class="number">0</span>||chopstick[(i+<span class="number">1</span>)%N]==<span class="number">0</span>)</span><br><span class="line">  pthread_cond_wait(&amp;cond_Var,&amp;mutex);<span class="comment">//判断i号哲学家左右两边是否有筷子，如果没有就等待</span></span><br><span class="line">  chopstick[i]--;</span><br><span class="line">  chopstick[(i+<span class="number">1</span>)%N]--;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d eating\n&quot;</span>,i);<span class="comment">//哲学家拿到筷子便开始吃饭</span></span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  pthread_mutex_lock(&amp;mutex);</span><br><span class="line">  chopstick[i]++;</span><br><span class="line">  chopstick[(i+<span class="number">1</span>)%N]++;</span><br><span class="line">  return_forks(i);<span class="comment">//哲学家吃完饭放下筷子开始思考</span></span><br><span class="line">  pthread_cond_signal(&amp;cond_Var);<span class="comment">//i号哲学家吃完，告诉其他哲学家筷子可用</span></span><br><span class="line">  pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,arr[N]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//定义哲学家编号 </span></span><br><span class="line">  pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">  pthread_mutex_init(&amp;num,<span class="literal">NULL</span>);</span><br><span class="line">  pthread_cond_init(&amp;cond_Var,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">pthread_t</span> phil[N];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   pthread_create(phil+i,<span class="literal">NULL</span>,(<span class="type">void</span>*)&amp;philosopher,&amp;arr[i]);<span class="comment">//创建六个哲学家线程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//等待子线程结束</span></span><br><span class="line">  &#123;</span><br><span class="line">   pthread_join(phil[i],<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编译并执行"><a class="markdownIt-Anchor" href="#编译并执行">#</a> 编译并执行：</h5><p><img src="http://img.sunsetsy.top/img/202403061502430.png" alt></p><h5 id="执行结果"><a class="markdownIt-Anchor" href="#执行结果">#</a> 执行结果：</h5><img src="http://img.sunsetsy.top/img/202403061503797.png" style="zoom: 80%;"> <h3 id="322-条件变量同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#322-条件变量同步互斥关键代码说明">#</a> 3.2.2 条件变量同步互斥关键代码说明</h3><p>（1）想吃饭的哲学家数量为临界资源，对其进行上锁</p><p>​pthread_mutex_lock (&amp;num);// 对临界资源上锁<br>​philosopher_num–;<br>​pthread_mutex_unlock(&amp;num);</p><p>（2）哲学家进行吃饭时，通过 pthread_mutex_lock (&amp;mutex) 对哲学家访问筷子临界资源进行上锁。当拿不到左右筷子时进行等待。while 循环是为了被唤醒后继续进行条件判断。当条件满足时 wait () 将线程阻塞后会释放互斥锁 lock, 以便其他进程能访问共享变量。别唤醒后进行上锁，以免其他线程进入。</p><p>​pthread_mutex_lock(&amp;mutex);</p><p>​    while(chopstick[i]==0||chopstick[(i+1)%N]==0)</p><p>pthread_cond_wait(&amp;cond_Var,&amp;mutex);</p><p>chopstick[i]–;</p><p>chopstick[(i+1)%N]–;</p><p>printf (&quot;% d eating\n&quot;,i);// 哲学家拿到筷子便开始吃饭</p><p>pthread_mutex_unlock(&amp;mutex);</p><p>（3）哲学家吃完饭，放下筷子然后通过 pthread_cond_signal (&amp;cond_Var) 发送信号告诉其他哲学家他左右两边筷子可用，让等待的线程可以继续运行</p><p>pthread_mutex_lock(&amp;mutex);</p><p>chopstick[i]++;</p><p>chopstick[(i+1)%N]++;</p><p>return_forks (i);// 哲学家吃完饭放下筷子开始思考</p><p>pthread_cond_signal (&amp;cond_Var);//i 号哲学家吃完告诉其他哲学家筷子可用</p><p>pthread_mutex_unlock(&amp;mutex);</p><h2 id="33-信号量同步互斥方法实现"><a class="markdownIt-Anchor" href="#33-信号量同步互斥方法实现">#</a> 3.3 信号量同步互斥方法实现</h2><h3 id="331-信号量同步互斥示例代码"><a class="markdownIt-Anchor" href="#331-信号量同步互斥示例代码">#</a> 3.3.1 信号量同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> rw_mutex;<span class="comment">//用于对读写进程互斥的访问</span></span><br><span class="line"><span class="type">sem_t</span> mutex;<span class="comment">//用于对read_count变量同步互斥的访问</span></span><br><span class="line"><span class="type">int</span> read_count=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span>* <span class="title function_">reading</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  sem_wait(&amp;mutex);<span class="comment">//对临界资源read_count进行上锁</span></span><br><span class="line">  read_count++;</span><br><span class="line">  <span class="keyword">if</span> (read_count==<span class="number">1</span>)<span class="comment">//第一个读者拿到锁后，其他读者可以直接进入</span></span><br><span class="line">   sem_wait(&amp;rw_mutex);</span><br><span class="line">  sem_post(&amp;mutex);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d号读者正在读取数据！\n&quot;</span>,*(<span class="type">int</span>*)arg);</span><br><span class="line">  sem_wait(&amp;mutex);</span><br><span class="line">  read_count--;</span><br><span class="line">  <span class="keyword">if</span>(read_count==<span class="number">0</span>)<span class="comment">//最后一个读者释放锁</span></span><br><span class="line">   sem_post(&amp;rw_mutex);</span><br><span class="line">  sem_post(&amp;mutex);</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span>* <span class="title function_">writing</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   sem_wait(&amp;rw_mutex);<span class="comment">//争夺互斥量，与读进程进行互斥的访问</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;正在写入数据！\n&quot;</span>);</span><br><span class="line">   sem_post(&amp;rw_mutex);</span><br><span class="line">   sleep(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,reader_id[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//定义读者编号</span></span><br><span class="line">  sem_init(&amp;rw_mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">  sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="type">pthread_t</span> reader[<span class="number">5</span>],writer;</span><br><span class="line">  <span class="comment">//创建写者线程</span></span><br><span class="line">  pthread_create(&amp;writer,<span class="literal">NULL</span>,(<span class="type">void</span>*)&amp;writing,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//创建5个读者线程</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   pthread_create(reader+i,<span class="literal">NULL</span>,(<span class="type">void</span>*)&amp;reading,&amp;reader_id[i]);</span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//等待读者线程结束，写线程中有while循环，不用等待它结束</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   pthread_join(reader[i],<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sem_destroy(&amp;rw_mutex);</span><br><span class="line">  sem_destroy(&amp;mutex);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编译后执行"><a class="markdownIt-Anchor" href="#编译后执行">#</a> 编译后执行：</h5><p><img src="http://img.sunsetsy.top/img/202403061503684.png" alt></p><h5 id="运行结果-2"><a class="markdownIt-Anchor" href="#运行结果-2">#</a> 运行结果：</h5><img src="http://img.sunsetsy.top/img/202403061503333.png" style="zoom:80%;"> <h3 id="332-信号量同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#332-信号量同步互斥关键代码说明">#</a> 3.3.2 信号量同步互斥关键代码说明</h3><p>（1）对读者线程，首先对 read_count 临界资源上锁，并将读者数量加 1，如果是第一个读者拿到锁，那么其他读者不再需要与写者进行争夺锁便可以读取数据。</p><p>当剩最后一个读者时，读完数据后将读 / 写进程锁释放。<em>(int</em>) arg 为线程 (读者) 编号。</p><p>sem_wait(&amp;mutex);</p><p>read_count++;</p><p>if (read_count==1)</p><p>sem_wait(&amp;rw_mutex);</p><p>sem_post(&amp;mutex);</p><p>printf (&quot;% d 号读者正在读取数据！\n&quot;,<em>(int</em>)arg);</p><p>sem_wait(&amp;mutex);</p><p>read_count–;</p><p>if(read_count==0)</p><p>sem_post(&amp;rw_mutex);</p><p>sem_post(&amp;mutex);</p><p>（2）写者进程通过 while 循环一直进行写操作，争躲到读 / 写进程锁就可以进行数据写入</p><p>​while(1)</p><p>​{</p><p>​ sem_wait(&amp;rw_mutex);</p><p>​ printf (“正在写入数据！\n”);</p><p>​sem_post(&amp;rw_mutex);</p><p>​}</p><p>（3）sem_post () 函数（函数原型 int sem_wait (sem_t * sem);）<br>作用是给信号量的值加上一个 “1”。 当有线程阻塞在这个信号量上时，调用这个函数会使其中一个线程不在阻塞，选择机制是有线程的调度策略决定的。</p><p>​sem_wait () 函数（函数原型 int sem_wait (sem_t * sem);）<br>它的作用是从信号量的值减去一个 “1”，但它永远会先等待该信号量为一个非零值才开始做减法。</p><h2 id="34屏障同步互斥方法实现"><a class="markdownIt-Anchor" href="#34屏障同步互斥方法实现">#</a> 3.4 屏障同步互斥方法实现</h2><h3 id="341-屏障同步互斥示例代码"><a class="markdownIt-Anchor" href="#341-屏障同步互斥示例代码">#</a> 3.4.1 屏障同步互斥示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 7 </span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;<span class="comment">//定义屏障</span></span><br><span class="line"><span class="type">double</span> ave;<span class="comment">//平均分</span></span><br><span class="line"><span class="type">int</span> min,max;<span class="comment">//最低分和最高分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算去掉最低分和最高分之后的平均分</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">average</span><span class="params">(<span class="type">int</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   sum+=arg[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*等待两个子线程找出最低分和最高分后，然后再来求平均分*/</span></span><br><span class="line">  pthread_barrier_wait(&amp;barrier);<span class="comment">//到达屏障点,停止等待</span></span><br><span class="line">  <span class="comment">/*等所有线程到达屏障点后,继续运行求出平均值在主线程中输出*/</span></span><br><span class="line">  ave=(sum-min-max)/(N<span class="number">-2.0</span>);</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到最低分</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mininum</span><span class="params">(<span class="type">int</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,j;</span><br><span class="line">  min=arg[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(arg[i]&lt;min)</span><br><span class="line">   &#123;</span><br><span class="line">      min=arg[i];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The mininum value is %d\n&quot;</span>,min);</span><br><span class="line">  pthread_barrier_wait(&amp;barrier);<span class="comment">//到达屏障点,停止等待</span></span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到最高分</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">maxinum</span><span class="params">(<span class="type">int</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,j;</span><br><span class="line">  max=arg[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(arg[i]&gt;max)</span><br><span class="line">   &#123;</span><br><span class="line">      max=arg[i];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The maxinum value is %d\n&quot;</span>,max);</span><br><span class="line">  pthread_barrier_wait(&amp;barrier);<span class="comment">//到达屏障点,停止等待</span></span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">8</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个数值\n&quot;</span>,N);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i,<span class="built_in">array</span>[N];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//将命令行输入的参数存入数组中</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">array</span>[i]=atoi(argv[i+<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">pthread_t</span> tid1,tid2,tid3;</span><br><span class="line">  <span class="comment">/*初始化屏障，设置需到达屏障的数目为3(3个子线程)*/</span></span><br><span class="line">  pthread_barrier_init(&amp;barrier,<span class="literal">NULL</span>,<span class="number">4</span>);</span><br><span class="line">  pthread_create(&amp;tid1,<span class="literal">NULL</span>,(<span class="type">void</span>*)&amp;average,<span class="built_in">array</span>);</span><br><span class="line">  pthread_create(&amp;tid2,<span class="literal">NULL</span>,(<span class="type">void</span>*)&amp;maxinum,<span class="built_in">array</span>);</span><br><span class="line">  pthread_create(&amp;tid3,<span class="literal">NULL</span>,(<span class="type">void</span>*)&amp;mininum,<span class="built_in">array</span>);</span><br><span class="line">  pthread_join(tid1,<span class="literal">NULL</span>);<span class="comment">//等待tid1线程求出平均值，以免主线程先结束</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The final score is %.1f\n&quot;</span>,ave);</span><br><span class="line">  pthread_barrier_destroy(&amp;barrier);<span class="comment">//释放屏障资源</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编译代码"><a class="markdownIt-Anchor" href="#编译代码">#</a> 编译代码：</h5><p><img src="http://img.sunsetsy.top/img/202403061504514.png" alt></p><h5 id="运行结果-3"><a class="markdownIt-Anchor" href="#运行结果-3">#</a> 运行结果：</h5><p><img src="http://img.sunsetsy.top/img/202403061505744.png" alt></p><h3 id="342-屏障同步互斥关键代码说明"><a class="markdownIt-Anchor" href="#342-屏障同步互斥关键代码说明">#</a> 3.4.2 屏障同步互斥关键代码说明</h3><p>（1）对于求平均分线程，要等待两个子线程找出最低分和最高分后，才能求最后的得分。</p><p>通过设置屏障，等待其他线程到达该点后，继续并发执行求出最后的平均分 ave。最后在主线程中输出平均分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">sum+=arg[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_barrier_wait(&amp;barrier);<span class="comment">//到达屏障点,停止等待 </span></span><br><span class="line"></span><br><span class="line">ave=(sum-min-max)/(N<span class="number">-2.0</span>);</span><br></pre></td></tr></table></figure><p>(2) 对于另外两个子线程，当求出最大值和最小值后，表明自己的工作已经完成。并输出最大值和最小值。</p><p>​ printf(“The maxinum value is %d\n”,max);</p><p>​ pthread_barrier_wait(&amp;barrier);</p><p>​ printf(“The mininum value is %d\n”,min);</p><p>​ pthread_barrier_wait(&amp;barrier);</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web静态网页</title>
      <link href="/2022/09/14/Web%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/"/>
      <url>/2022/09/14/Web%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="1-猜数游戏"><a class="markdownIt-Anchor" href="#1-猜数游戏">#</a> 1. 猜数游戏</h3><ul><li><p>用户点击开始，在 0-100 内随机生成一个整数，输入你想猜的数字，点击提交。</p><p>演示界面：</p><p><img src="http://img.sunsetsy.top/img/202403061455857.png" alt></p><p><a href="https://yellowsy.github.io/html/%E7%8C%9C%E6%95%B0.html">猜数游戏 - 演示地址</a></p></li></ul><h3 id="2-照亮黑暗"><a class="markdownIt-Anchor" href="#2-照亮黑暗">#</a> 2. 照亮黑暗</h3><ul><li><p>用户鼠标在页面停留，界面以用户的鼠标为中心形成光圈。</p><p>演示界面：</p><img src="http://img.sunsetsy.top/img/202403061455686.png" style="zoom: 50%;"> </li></ul><p>​<a href="https://yellowsy.github.io/html/%E7%85%A7%E4%BA%AE%E9%BB%91%E6%9A%97.html">照亮黑暗 - 演示地址</a></p><h3 id="3碰撞小球"><a class="markdownIt-Anchor" href="#3碰撞小球">#</a> 3. 碰撞小球</h3><ul><li><p>用户可以点击小球并划动它，使它们相互碰撞。</p><p>演示界面：</p><img src="http://img.sunsetsy.top/img/202403061456684.png" style="zoom: 67%;"> </li></ul><p>​<a href="https://yellowsy.github.io/html/%E7%A2%B0%E6%92%9E%E5%B0%8F%E7%90%83.html">碰撞小球 - 演示地址</a></p><h3 id="4电影购票"><a class="markdownIt-Anchor" href="#4电影购票">#</a> 4. 电影购票</h3><ul><li><p>用户点击选座位，侧栏显示对应座位信息，也可以取消已选择的座位，则删除对应的座位信息，点击下单，显示付款金额，最多可购选五张票。</p><p>演示界面：</p><img src="http://img.sunsetsy.top/img/202403061457462.png" style="zoom:50%;"><p><a href="https://yellowsy.github.io/html/%E7%94%B5%E5%BD%B1%E8%B4%AD%E7%A5%A8.html">电影购票 - 演示地址</a></p></li></ul><h3 id="5加载进度动画"><a class="markdownIt-Anchor" href="#5加载进度动画">#</a> 5. 加载进度动画</h3><ul><li><p>演示界面：</p><p><img src="http://img.sunsetsy.top/img/202403061458436.png" alt></p></li><li><p><a href="https://yellowsy.github.io/html/css3-3d-loading/index.html">加载进度动画 - 演示地址</a></p></li></ul><h3 id="6简约的登录界面"><a class="markdownIt-Anchor" href="#6简约的登录界面">#</a> 6. 简约的登录界面</h3><ul><li><p>一个酷炫的用户登录界面。</p><p>演示界面：</p><img src="http://img.sunsetsy.top/img/202403061458909.png" style="zoom:67%;"> </li></ul><p>​<a href="https://yellowsy.github.io/html/css3-login-lighting-button/index.html">简约的登录界面 - 演示地址</a></p><h3 id="7转动时钟"><a class="markdownIt-Anchor" href="#7转动时钟">#</a> 7. 转动时钟</h3><ul><li><p>一个简介的钟表显示当前时间。</p><p>演示界面：</p><img src="http://img.sunsetsy.top/img/202403061459376.png" style="zoom:67%;"> </li></ul><p>​<a href="https://yellowsy.github.io/html/html5-apple-watch-clock-face/index.html">转动时钟 - 演示地址</a></p><h3 id="8神秘游戏场景动画"><a class="markdownIt-Anchor" href="#8神秘游戏场景动画">#</a> 8. 神秘游戏场景动画</h3><ul><li><p>一个 3D 模型，用户可放大缩小和旋转。</p><p>演示界面：</p><p><img src="http://img.sunsetsy.top/img/202403061459644.png" alt></p></li></ul><p>​<a href="https://yellowsy.github.io/html/html5-3d-game-scene/index.html">神秘游戏场景动画 - 演示地址</a></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2022/09/13/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/13/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="1-常用命令"><a class="markdownIt-Anchor" href="#1-常用命令">#</a> 1. 常用命令</h3><h5 id="重启网卡"><a class="markdownIt-Anchor" href="#重启网卡">#</a> 重启网卡</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network  </span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure><h5 id="用户切换"><a class="markdownIt-Anchor" href="#用户切换">#</a> 用户切换</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su hsy（普通用户）</span><br><span class="line">su - (切换到root用户)</span><br></pre></td></tr></table></figure><h5 id="关机"><a class="markdownIt-Anchor" href="#关机">#</a> 关机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">halt  </span><br><span class="line">shutdown -h now (立即关机)   </span><br><span class="line">shutdown -h +5(五分钟以后关机)</span><br><span class="line">shutdown -c (取消关机)</span><br><span class="line">init 0 (关机) ；init 6 (重启)</span><br></pre></td></tr></table></figure><h5 id="使用-一次输入多个命令"><a class="markdownIt-Anchor" href="#使用-一次输入多个命令">#</a> 使用 &quot;；&quot; 一次输入多个命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 ;  command2 ; command3</span><br></pre></td></tr></table></figure><h5 id="常用小技巧"><a class="markdownIt-Anchor" href="#常用小技巧">#</a> 常用小技巧</h5><ul><li>显示或操作命令历史列表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure><ul><li><p>补全路径</p><ul><li>文件或目录的首几个字母 + Tab</li></ul></li><li><p>显示上一条路径</p><ul><li>Esc+.  (点)</li></ul></li></ul><h3 id="2-操作文件和目录"><a class="markdownIt-Anchor" href="#2-操作文件和目录">#</a> 2. <strong>操作文件和目录</strong></h3><h5 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件">#</a> 删除文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm file 删除文件（可以不为空删除）</span><br><span class="line">rm -f flie 强制删除</span><br><span class="line">rm -r 目录名   递归删除目录（该目录下可以有其他文件，被一起删除）</span><br><span class="line">rmdir 删除空目录 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="创建目录"><a class="markdownIt-Anchor" href="#创建目录">#</a> 创建目录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir--创建目录   </span><br><span class="line">mkdir dir1创建一个目录</span><br><span class="line">mkdir dir1 dir2 dir3 一次创建多个目录</span><br><span class="line">mkdir -p dir1/dir2 递归生成目录dir1和dir2,即dir1为当前目录的子目录，dir2为dir1的子目录</span><br></pre></td></tr></table></figure><h5 id="复制文件和目录"><a class="markdownIt-Anchor" href="#复制文件和目录">#</a> 复制文件和目录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp item1 item2 将文件或目录item1复制到item2</span><br><span class="line">cp -r  递归复制目录</span><br><span class="line">cp -p 保留源文件的属性不变</span><br></pre></td></tr></table></figure><h5 id="移动和重命名文件"><a class="markdownIt-Anchor" href="#移动和重命名文件">#</a> 移动和重命名文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv item1 item2 将文件或目录item1移动或重命名为item2</span><br></pre></td></tr></table></figure><h5 id="创建硬链接和链接符号"><a class="markdownIt-Anchor" href="#创建硬链接和链接符号">#</a> 创建硬链接和链接符号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ln file link  创建硬链接   （就是为文件额外创建一个目录项）</span><br><span class="line">a.硬链接不能引用目录，只能引用文件</span><br><span class="line">b.硬链接不能跨物理设备</span><br><span class="line">ln -s item link 创建链接符号  （item可以是文件和目录）</span><br><span class="line">相当于用文本描述目标文件相对于符号链接的位置</span><br></pre></td></tr></table></figure><h3 id="3初步探索linux"><a class="markdownIt-Anchor" href="#3初步探索linux">#</a> 3.<strong> 初步探索 Linux</strong></h3><h5 id="使用ls命令之乐"><a class="markdownIt-Anchor" href="#使用ls命令之乐">#</a> 使用 ls 命令之乐</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.  (一个点) 表示在当前目录</span><br><span class="line">ls 查看当前目录所包含的文件和子目录</span><br><span class="line">ls -l  将输出结果改成长格式</span><br><span class="line">ls -a  列出所有文件</span><br><span class="line">ls -d  显示目录本身的属性，而非其内部的文件列表  （只显示目录本身）</span><br><span class="line">ls -h  人性化显示容量信息，以K、M、G等单位表示文件大小。</span><br></pre></td></tr></table></figure><h5 id="使用file命令确定文件类型"><a class="markdownIt-Anchor" href="#使用file命令确定文件类型">#</a> 使用 file 命令确定文件类型</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure><h5 id="使用less命令查看文本文件"><a class="markdownIt-Anchor" href="#使用less命令查看文本文件">#</a> 使用 less 命令查看文本文件</h5><ul><li>键 G  移动到文件末尾</li><li>键 Q  退出 less 命令</li></ul><h5 id="通配符"><a class="markdownIt-Anchor" href="#通配符">#</a> 通配符</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*  匹配任意多个字符</span><br><span class="line">  ls -d  /etc/*conf*   显示/etc目录下所有名字中包括“conf”的文件或目录。</span><br><span class="line">  ls -d /etc/pa*  列出/etc目录下所有以“pa”开头的文件或目录，j加上 -d 只显示目录本身,不显示其内容</span><br><span class="line">？ 匹配任意单个字符</span><br><span class="line">  ls -lh /dev/sa?  以长格式列出/dev目录中所有以“sd”开头并且文件名只有3个字符的文件信息。(sa给定，第三个字符任意(即？))</span><br><span class="line">通配符“[ ]”可以匹配指定范围内的任意单个字符。</span><br><span class="line">  ls /dev/[a-c]*列出/dev/目录中以“a”、“b”、“c”开头的所有文件。</span><br></pre></td></tr></table></figure><h5 id="时间戳"><a class="markdownIt-Anchor" href="#时间戳">#</a> 时间戳</h5><ul><li>访问时间 (access time:atime): 上一次文件访问时间；</li><li>内容修改时间 (modified time:mtime): 上次文件内容修改时间；</li><li>元信息改变时间 (change time:ctime): 上次文件属性改变时间；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat -[选项] [文件]   查看文件的元信息</span><br></pre></td></tr></table></figure><h3 id="4和命令打交道"><a class="markdownIt-Anchor" href="#4和命令打交道">#</a> 4. 和命令打交道</h3><h5 id="识别命令"><a class="markdownIt-Anchor" href="#识别命令">#</a> 识别命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显示命令类型</span><br><span class="line">type  command(要检查的文件名)</span><br><span class="line">显示可执行文件的位置</span><br><span class="line">which command  </span><br></pre></td></tr></table></figure><h5 id="获取命令文档"><a class="markdownIt-Anchor" href="#获取命令文档">#</a> 获取命令文档</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">help--获取Shell内建命令的帮助信息</span><br><span class="line">例如：help cd</span><br><span class="line">--help  显示用法信息</span><br><span class="line">mkdir --help</span><br><span class="line">man 显示命令的手册页</span><br><span class="line">例如 man ls</span><br><span class="line">man section search_term  ；section指明节号</span><br><span class="line">man -k 根据关键字查找</span><br><span class="line">显示适合的命令清单（根据关键字查找）</span><br><span class="line">apropos partition(关键字)</span><br><span class="line">whatis --显示手册页的简述</span><br><span class="line">info--显示程序的info条目</span><br></pre></td></tr></table></figure><h5 id="使用alias创建自己的命令"><a class="markdownIt-Anchor" href="#使用alias创建自己的命令">#</a> 使用 alias 创建自己的命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias name=&#x27;string&#x27;    (name为自己所起的名字，string为命令)</span><br><span class="line">使用unalias命令可以删除别名</span><br></pre></td></tr></table></figure><h3 id="5重定向"><a class="markdownIt-Anchor" href="#5重定向">#</a> 5. 重定向</h3><h5 id="标准输出重定向"><a class="markdownIt-Anchor" href="#标准输出重定向">#</a> 标准输出重定向</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将ls -l /usr/bin  的输出结果保存在ls-output.txt中</span><br><span class="line">ls - l/usr/bin &gt; ls-output.txt   （ls的结果本来应该输出在屏幕上）</span><br><span class="line">将重定向的标准输出追加到文件尾，而不是将其从头覆盖</span><br><span class="line">使用 &gt;&gt; :  ls - l/usr/bin &gt;&gt; ls-output.txt</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">覆盖重定向  ； &gt;&gt; 追加重定向</span></span><br></pre></td></tr></table></figure><h5 id="标准错误重定向"><a class="markdownIt-Anchor" href="#标准错误重定向">#</a> 标准错误重定向</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标准错误重定向对应的描述符为2，以下将输出错误信息定向到 ls-error.txt</span><br><span class="line">例：ls -l /bin/usr  2&gt; ls-error.txt</span><br></pre></td></tr></table></figure><h5 id="标准输入重定向"><a class="markdownIt-Anchor" href="#标准输入重定向">#</a> 标准输入重定向</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat 将键盘输入的内容在屏幕上原样输出</span><br><span class="line">cat 命令读取一个或多个文件并将其复制到标准输出（显示文本文件内容）</span><br><span class="line">创建一个文件存放从键盘输入的字符</span><br><span class="line"> a.cat lazy_dog.txt （换行）The quick brown fox jumped over the lazy dog.</span><br><span class="line"> b.查看lazy_dog .txt文件 例：cat lazy_dog.txt或者cat&lt;lazy_dog.txt</span><br></pre></td></tr></table></figure><h5 id="管道"><a class="markdownIt-Anchor" href="#管道">#</a> 管道</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">管道符“|”用于连接左右两个命令，将“I”左边命令的执行结果作为“|”右边命令的输入</span><br><span class="line">  将标准输出的命令用less命令将其结果逐页显示出来</span><br><span class="line">ls -l /usr/bin | less</span><br><span class="line">排序列表</span><br><span class="line">ls  /bin/usr/bin  | sort |  less</span><br><span class="line">uniq--报告或忽略重复行</span><br><span class="line">ls  /bin/usr/bin | sort | uniq | less</span><br><span class="line">wc 统计文件中换行符，单词以及直字节的数量</span><br><span class="line">wc ls-error.txt   (输出三个数字分别是：行数，单词数，字节数)</span><br><span class="line">wc -l 限制只输出文件行数</span><br><span class="line">grep 输出与模式匹配的行</span><br><span class="line">grep pattren filename</span><br><span class="line">-i 使grep命令在搜索的时候忽略字母的大小写</span><br><span class="line">-v 使grep命令只输出不匹配指定模式的行</span><br><span class="line">-r 可以匹配关键字在当前目录下的子目录中查找</span><br><span class="line">   head/tall 输出文件的开头/结尾部分（默认十行）</span><br><span class="line">head -n 5 ls-output.txt (注意是文件)</span><br><span class="line">运用在管道中：ls  /usr/bin |tail -n 5</span><br><span class="line">tail -f 持续观察文件，一旦文件中添加新行，立即显示在屏幕中，ctrl+c停止</span><br><span class="line">tee 读取标准输入并将输出结果写入标准输出的文件id</span><br><span class="line">diff file1 file2  比较两个文件的不同；结果中的a,b,c分别代表添加，删除和修改;以&quot;&lt;&quot;开始的行属于文件1，以“&gt;”开始的行属于文件2。</span><br></pre></td></tr></table></figure><h3 id="6-shell眼看世界"><a class="markdownIt-Anchor" href="#6-shell眼看世界">#</a> 6. Shell 眼看世界</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算术扩展(仅支持整数，不支持小数)</span><br><span class="line">   echo $((expression))    echo $((2+2))</span><br><span class="line">/  : 除法 ，结果为整数</span><br><span class="line">*  : 求幂</span><br><span class="line">花括号扩展</span><br><span class="line">echo Front-&#123;A,B,C&#125;-Back</span><br><span class="line">  结果：Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line">echo &#123;01..15&#125;</span><br><span class="line">  01 02 03 04 05 06 07 08 09 10 11 12 13 14 15</span><br></pre></td></tr></table></figure><h3 id="7-高级键盘技巧"><a class="markdownIt-Anchor" href="#7-高级键盘技巧">#</a> 7. 高级键盘技巧</h3><h5 id="光表移动"><a class="markdownIt-Anchor" href="#光表移动">#</a> 光表移动</h5><ul><li>Ctrl+A      将光标移动到首行</li><li>Ctrl+E      将光标移动到行尾</li><li>Ctrl+F      将光标 v 向前移动一个字符；等同于右方向键位</li><li>Ctrl+B      将光表向后移动一个字符；等同于左方向键位</li><li>Ctrl+L      清除屏幕，将光标移动到左上角。等同于 clear 命令</li></ul><h5 id="修改文本"><a class="markdownIt-Anchor" href="#修改文本">#</a> 修改文本</h5><ul><li>Ctrl+D      删除光标处的字符</li><li>Ctrl+T      将光标出的字符与其之前的单词对调</li></ul><h5 id="剪切和粘贴文本"><a class="markdownIt-Anchor" href="#剪切和粘贴文本">#</a> 剪切和粘贴文本</h5><ul><li>Ctrl+K      剪切从光标处到行尾的文本</li><li>Ctrl+U      剪切从光标处到行首的文本</li><li>Ctrl+Y      将 kill-ring 缓冲区内的文本粘贴到光标</li></ul><h5 id="搜索历史记录"><a class="markdownIt-Anchor" href="#搜索历史记录">#</a> 搜索历史记录</h5><ul><li>Ctrl+P  移动到上一条搜索记录。等同于使用上方向建</li><li>Ctrl+N  移动到下一条搜索记录。等同于使用下方向建</li><li>Ctrl+R  反向增量搜索。从当前命令行开始向上增量搜索历史记录列表</li><li>Ctil+O   执行历史记录列表中的当前命令并移动到下一条命令。如果你想要重复执行历史列表中的一系列命令，该组合键非常方便</li><li>！！  重复上一条命令</li><li>！number 重复命令历史记录列表中第 number 个命令</li></ul><h3 id="8-文件访问权限"><a class="markdownIt-Anchor" href="#8-文件访问权限">#</a> 8. 文件访问权限</h3><h5 id="文件权限修改"><a class="markdownIt-Anchor" href="#文件权限修改">#</a> 文件权限修改</h5><ul><li><p>3 种基本操作：读 ®， 写 (w)， 执行 (x)；</p></li><li><p>3 类用户划分：文件拥有者 (user)，文件所属组 (group)，其他用户 (other)；</p></li><li><p>文件访问权限可以使用命令 chmod 修改；</p><ul><li>chmod mode|octal-mode File…<ul><li>按照 mode 或 octal-mode 描述的方式设置 File 的访问权限</li></ul></li></ul></li><li><p>mode: 字符形式描述的权限:[ugoa][-+=][rwxXst]</p></li><li><p>ugoa：u (拥有者)，g (所有组)，o (其他用户)，a (所有用户)</p></li><li><p>stat 命令查看文件元信息文件类型文件访问权限</p></li><li><p>-+=：-(删除权限)，+(增加权限)，=(重设权限)</p></li><li><p>rwxXst：r (读)，w (写)，r (执行)，s (suid 或 sgid)，t (sticky bit)</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod a=rwx file   设置文件file的访问权限为所有用户可读/写/执行</span><br><span class="line">修改后file的文件权限为：-rwxrwxrwx  . u=rwx  g=rwx  o=rwx</span><br></pre></td></tr></table></figure><ul><li>octal-mode：八进制形式描述的权限：[-+=][0-7]+<ul><li>-+=：-(删除权限)，+(增加权限)，=(重设权限)</li><li>[0-7]+：表示数 0-7 可重复多次，通常可以有 4 个<ul><li>第 1 个八进制数表示特殊权限：4 (suid)，2 (sgid)，1 (sticky bit)</li><li>第 2 个八进制数表示拥有者权限：4®，2 (w)，1 (x)</li><li>第 3 个八进制数表示所属组权限：4®，2 (w)，1 (x)</li><li>第 4 个八进制数表示其他用户权限：4®，2 (w)，1 (x)</li></ul></li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/yellowsy/cloudimg/main/img/202211242041674.png" alt></p><h5 id="文件默认权限umark掩码"><a class="markdownIt-Anchor" href="#文件默认权限umark掩码">#</a> 文件默认权限 umark 掩码</h5><ul><li><p>显示或修改 umask 掩码 (用于决定新建文件时如何赋予权限)</p></li><li><p>umask 掩码的默认值通常设置为 002 或 022；</p></li><li><p>假设 umask 掩码值为 022：</p></li><li><p>新建文件时：将文件权限设置为 666-022=644，即 rw-r–r--；</p></li><li><p>新建目录时：将目录权限设置为 777-022=755，即 rwxr-xr-x；</p></li><li><p>umask</p></li><li><p>查看 umask 掩码值；</p></li><li><p>umask nnn</p></li><li><p>临时修改 umask 掩码值为 nnn (由 3 个八进制数组成)；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适合发朋友圈的文案</title>
      <link href="/2022/09/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/09/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>1. 梅花何止落满一整座南山</p><p>2. 我已经懒得沟通了 你说夜里有太阳我都认<br>爱哪里是神殿 分明是十里扬州、灯火不休<br>你是落日弥漫的橘 天边透亮的星<br>我与春风皆过客 你携秋水揽星河</p><p>3. 梦里不觉人间晚 回首山河遍地秋<br>空有一身热爱 却入不了这山海<br>毕竟你是太阳 不是我一个人的光<br>其实雨不大 是风搞得紧张</p><p>4. 宫崎骏曾经说过 当陪你的那个人 要下车时 即使你在不舍 你也要心存感激 挥手告别 没个人的故事 开头都是极具温柔的 但往往故事的结尾都配不上整个开头 记住 没一个意难平的结果 都是我们最好的结局</p><p>5. 爱意随风起 却不随风散 这路遥马急的人间 你在我心里何止好几年</p><p>6.“一定要文采斐然吗，我磕磕绊绊，叙意不清的语句也是爱<br>一定要娓娓道来吗 我词不达意 语未由衷的叙述也是爱<br>一定要妙语连珠吗 我支支吾吾 含糊其辞的言语也是爱啊。”</p><p>7. 如果你喜欢冬天，那是因为有夏天的存在。那么人为什么要工作学习呢？是为了以后开心，如果你每天只是玩的话，那可能玩就不是一件特别开心的事。所以人要有束缚才会有自由，有痛苦才会有快乐。只有在忙碌的时候才能体会到闲暇的愉悦。光明也只有在黑暗中看到。</p><p><img src="http://img.sunsetsy.top/img/wallhaven-l3577p.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 文案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

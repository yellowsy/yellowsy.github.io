{"meta":{"title":"紫薯与你","subtitle":"","description":"","author":"Huang_SY","url":"https://yellowsy.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-09-12T12:05:35.303Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://yellowsy.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-09-17T08:22:24.621Z","updated":"2022-09-17T08:22:24.621Z","comments":true,"path":"about/index.html","permalink":"https://yellowsy.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"catedories","date":"2022-09-08T13:21:18.000Z","updated":"2022-09-08T13:21:18.168Z","comments":true,"path":"catedories/index.html","permalink":"https://yellowsy.github.io/catedories/index.html","excerpt":"","text":""},{"title":"search","date":"2022-09-08T13:18:32.000Z","updated":"2022-09-08T13:18:32.223Z","comments":true,"path":"search/index.html","permalink":"https://yellowsy.github.io/search/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-15T08:28:14.837Z","updated":"2022-09-15T08:28:14.837Z","comments":true,"path":"categories/index.html","permalink":"https://yellowsy.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-09-12T12:05:35.303Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"https://yellowsy.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-09-15T07:38:06.513Z","updated":"2022-09-15T07:38:06.513Z","comments":true,"path":"links/index.html","permalink":"https://yellowsy.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-15T08:25:12.213Z","updated":"2022-09-15T08:25:12.213Z","comments":true,"path":"tags/index.html","permalink":"https://yellowsy.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-09-12T12:05:35.303Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"https://yellowsy.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"编写shell脚本并启动","slug":"编写shell脚本并启动","date":"2022-09-25T15:14:12.000Z","updated":"2022-09-26T14:23:18.425Z","comments":true,"path":"2022/09/25/编写shell脚本并启动/","link":"","permalink":"https://yellowsy.github.io/2022/09/25/%E7%BC%96%E5%86%99shell%E8%84%9A%E6%9C%AC%E5%B9%B6%E5%90%AF%E5%8A%A8/","excerpt":"","text":"一， 创建并执行Shell脚本 1. 脚本文件格式 编写一个脚本。 Shell 脚本就是普通的文本文件。所以我们需要一个文本编辑器来书写它们。最好的文本 编 辑器都会支持语法高亮，这样我们就能够看到一个脚本关键字的彩色编码视图。语法高亮会帮助我们查看某 种常见 错误。为了编写脚本文件，vim，gedit，kate，和许多其它编辑器都是不错的候选者。 使脚本文件可执行。 系统会相当挑剔不允许任何旧的文本文件被看作是一个程序，并且有充分的理由! 所以 我们需要设置脚本文件的权限来允许其可执行。 把脚本放置到 shell 能够找到的地方 当没有指定可执行文件明确的路径名时，shell 会自动地搜索某些目录， 来查找此可执行文件。为了最大程度的方便，我们会把脚本放到这些目录当中。 2. 创建一个hello_world文件，使用vim编辑 12345#!/bin/bash#这是我们的第一个脚本文件echo &#x27;Hello world!&#x27; 3. 可执行权限 使得脚本能够执行，用chmod设置权限 1$ chomd 755 hello_world(文件名) 4. 执行脚本 1$ ./hello_world ​ 执行结果： 二，编写html并在浏览器启动 1. 变量与常量 Shell并不在意变量赋值的数据类型，它将一切都视为字符串，可以之接为变量赋值 123title=&quot;System Infomation Report&quot;使用 &#x27;$&#x27; 符号引用变量echo $title 输出即为: System Infomation Report #a&#x3D;z 将字符串z赋给变量a #b&#x3D;”a string” 内嵌空格符的字符串必须放入双引号中 #c&#x3D;”a string and $b” 赋值中包含其他扩展（例如，变量扩展） #d&#x3D;”$(ls -l foo.txt)” 命令的执行结果 #e&#x3D;$((5*7)) 算术扩展 #f&#x3D;”\\t\\ta string \\n” 转义序列，例如制表符，换行符 2. 编写文件内容 创建文件sys_info_page，输入下列程序： 12345678910111213141516#!/bin/bash#程序输出一个系统信息页TITLE=&quot;System Information Report For $HOSTNAME&quot;#生成时间CURRENT_TIME=&quot;$(date +&quot;%x %r %Z&quot;)&quot;#创建者用户名TIMESTAMP=&quot;Generated $CURRENT_TIME ,by $USER&quot;echo &quot;&lt;html&gt; &lt;head&gt; &lt;title&gt;$TITLE&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 align=&quot;center&quot;&gt;$TITLE&lt;/h1&gt; &lt;p align=&quot;center&quot;&gt;$TIMESTAMP&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&quot; 说明：$HOSTNAME为主机名，$(date + &quot;%x %r %Z&quot;)为当前用户时间 设置sys_info_page可执行权限 12$ chmod 755 sys_info_page$ ./sys_info_page 当程序运行的时候，我们应该看到 HTML 文本在屏幕上显示出来，因为脚本中的 echo 命令会输出 发送到标准 输出。我们再次运行这个程序，把程序的输出重定向到文件 sys_info_page.html 中， 从而我们可以通过网络浏 览器来查看输出结果： 12$ ./sys_info_page &gt; sys_info_page.html$ firefox sys_info_page.html ​ 执行结果： 也可在浏览器地址栏中输入：file:&#x2F;&#x2F;文件所在路径，进行查看 Here Documents 我们已经知道了两种不同的文本输出方法，两种方法都使用了 echo 命令。还有第三种方法，叫做 here document 或者 here script。一个 here document 是另外一种 I&#x2F;O 重定向形式，我们 在脚本文件中嵌入正文 文本，然后把它发送给一个命令的标准输入。它这样工作： 123command &lt;&lt; tokentexttoken 这里的 command 是一个可以接受标准输入的命令名，token 是一个用来指示嵌入文本结束的字符串。 这个字符串_EOF_（意思是“文件结 尾”， 一个常见用法）被选作为 token，并标志着嵌入文本的结尾。注意这个 token 必须在一行中单独出现， 并且文本行中 没有末尾的空格。 来看以下命令行示例： 1234567891011$ foo=&quot;some text&quot;$ cat &lt;&lt; _EOF_&gt; $foo&gt; &quot;$foo&quot;&gt; &#x27;$foo&#x27;&gt; \\$foo&gt; _EOF_some text&quot;some text&quot;&#x27;some text&#x27;$foo 正如我们所见到的，shell 根本没有注意到引号。它把它们看作是普通的字符。这就允许我们 在一个 here document 中可以随意的嵌入引号。 如果我们把重定向操作符从 “&lt;&lt;” 改为 “&lt;&lt;-”，shell 会忽略在此 here document 中开头的 tab 字符。 三，Shell函数 1. shell函数两种语法形式 12345function name &#123; commands return&#125;注意name和 &#x27;&#123;&#x27; 之间有空格 ​ 另一种简单的形式： 1234name &#123; commands return&#125; 2. shell函数用法 123456789101112#!/bin/bash# Shell 函数展示function step2 &#123; //函数名与 &#x27;&#123;&#x27; 之间有空格 echo &quot;Step 2&quot; return &#125;#主函数起点echo &quot;Step 1&quot;step2echo &quot;Step 3&quot; 随着 shell 读取这个脚本，它会跳过第1行到第11行的代码，因为这些文本行由注释和函数定义组成。 从第12行 代码开始执行，有一个 echo 命令。第13行会调用 shell 函数 funct，然后 shell 会执行这个函数， 就如执行其 它命令一样。这样程序控制权会转移到第六行，执行第二个 echo 命令。然后再执行第7行。 这个 return 命令终 止这个函数，并把控制权交给函数调用之后的代码（第14行），从而执行最后一个 echo 命令。注意为了使函数 调用被识别出是 shell 函数，而不是被解释为外部程序的名字，所以在脚本中 shell 函数定义必须出现在函数调 用之前。 四，局部变量 局 部变量只能在定义它们的 shell 函数中使用，并且一旦 shell 函数执行完毕，它们就不存在了。 拥有局部变量允许程序员使用的局部变量名，可以与已存在的变量名相同，这些变量可以是全局变量， 或者是其 它 shell 函数中的局部变量，却不必担心潜在的名字冲突。 下面的例子演示局部变量的定义和用法： 123456789101112131415161718192021#!/bin/bash# local-vars: 演示本地变量的脚本foo=0 # global variable foofunct_1 () &#123; local foo # variable foo local to funct_1 foo=1 echo &quot;funct_1: foo = $foo&quot;&#125;funct_2 () &#123; local foo # variable foo local to funct_2 foo=2 echo &quot;funct_2: foo = $foo&quot;&#125;echo &quot;global: foo = $foo&quot;funct_1echo &quot;global: foo = $foo&quot;funct_2echo &quot;global: foo = $foo&quot; 执行结果： 正如我们所看到的，通过在变量名之前加上单词 local，来定义局部变量。这就创建了一个只对其所在的 shell 函 数起作用的变量。在这个 shell 函数之外，这个变量不再存在。我们对两个 shell 函数中的局部变量 foo 赋值，不会影响到在函数之外定义的变量 foo 的值。 这个功能就允许 shell 函数能保持各自以及与它们所在脚本之间的独立性。 五，完善我们的Shell脚本 在我们已编写的Shell脚本中添加以下功能： 系统正常运行时间和负载。这是自上次关机或重启之后系统的运行时间，以及在几个时间间隔内当前运行在 处理 中的平均任务量。 磁盘空间。系统中存储设备的总使用量。 家目录空间。每个用户所使用的存储空间数量。 1234命令介绍：uptime 系统正常运行时间和负载df -h 查看文件系统硬盘使用情况 -h参数：使用人们习惯的 KB、MB 或 GB 等单位自行显示容量；du -sh /home/* 查看home文件夹磁盘占用情况 需要root用户权限，如果在普通用户下，在命令前加上sudo 改写我们的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/bash#程序输出一个系统信息页#大写字母表示常量，小写字母表示变量TITLE=&quot;System Information Report For $HOSTNAME&quot;#生成时间CURRENT_TIME=&quot;$(date +&quot;%x %r %Z&quot;)&quot;#创建者用户名TIMESTAMP=&quot;Generated $CURRENT_TIME ,by $USER&quot;report_uptime () &#123; cat &lt;&lt;- _EOF_ &lt;h2&gt;System Uptime&lt;/h2&gt; &lt;pre&gt;$(uptime)&lt;/pre&gt; _EOF_ return&#125;report_disk_space () &#123; cat &lt;&lt;- _EOF_ &lt;h2&gt;Disk Space Utilization&lt;/h2&gt; &lt;pre&gt;$(df -h)&lt;/pre&gt; _EOF_ return&#125;report_home_space () &#123; cat &lt;&lt;- _EOF_ &lt;h2&gt;Home Space Utilization&lt;/h2&gt; &lt;pre&gt;$(sudo du -sh /home/*)&lt;/pre&gt; _EOF_ return&#125;cat &lt;&lt; _EOF_&lt;html&gt; &lt;head&gt; &lt;title&gt;$TITLE&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .box &#123; width: 400px; &#125; &lt;/style&gt; &lt;body&gt; &lt;h1 align=&quot;center&quot;&gt;$TITLE&lt;/h1&gt; &lt;p align=&quot;center&quot;&gt;$TIMESTAMP&lt;/p&gt; &lt;center&gt; $(report_uptime) &lt;div align=&quot;left&quot; class=&quot;box&quot;&gt; $(report_disk_space) &lt;/div&gt; $(report_home_space) &lt;/center&gt; &lt;/body&gt;&lt;/html&gt;_EOF_ 执行结果如下： 至此，我们成功启动我们编写的shell脚本文件。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yellowsy.github.io/tags/Linux/"}]},{"title":"idea使用内嵌的Tomcat获取前端用户信息","slug":"idea使用内嵌的Tomcat获取前端用户信息","date":"2022-09-22T07:31:50.000Z","updated":"2022-09-22T14:57:48.813Z","comments":true,"path":"2022/09/22/idea使用内嵌的Tomcat获取前端用户信息/","link":"","permalink":"https://yellowsy.github.io/2022/09/22/idea%E4%BD%BF%E7%94%A8%E5%86%85%E5%B5%8C%E7%9A%84Tomcat%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/","excerpt":"","text":"前后台通讯-前台发送数据到后台 工具：idea社区版 环境：(没有配置的可以参考以下链接) 配置Tomcat 配置Maven 介绍：在java代码中内嵌的Tomcat,使用main函数启动。加载html页面后，用户输入信息，获取后显示在控制台 步骤 idea中建立Maven项目 编写前端页面html，用户提交信息 创建Serlvet类，并在main函数中嵌入Tomcat代码 运行测试类的main函数，获取页面信息输入到后端 一. idea中建立Maven项目1.在Idea中配置maven 打开Idea，点击File，然后点击Settings，进入设置，或者直接按Ctrl+Alt+S进入设置 先在左上角的搜索框输入maven，找到maven后单击，然后在右边的maven home path的右边选择你的maven安装路径，选择到根目录就好了，然后点击确定，具体步骤看下图： Local repository 是maven的 本地仓库，默认路径是C:\\Users\\Administrator.m2\\repository，可以使用默认路径也可以在settings.xml中配置本地maven仓库，看自己需要，一般在settings.xml中配置好了这里会自动检测你在settings.xml中配置的仓库路径 ，具体步骤如下图： 2.在Idea中创建maven项目 点击File，选择New，再点击Project 建立maven工程，具体看图，别选错webapp了 接下来输入各类名称，填完后直接next下一步 配置maven信息，具体操作如下图： 添加配置 DarchetypeCatalog&#x3D;internal，添加原因：每次创建maven项目时， IDEA 要使用插件进行创建，这些插件当你创建新的项目时，它每次都会去中央仓库下载，这样使得创建比较慢。所以在创建maven项目时，应该让它找本地仓库中的插件进行项目的创建。 ​ DarchetypeCatalog=internal ​ 3.完善maven-web项目模板 第一次加载maven项目比较慢，等待右下角的进度条加载结束，下面是刚建好的maven-web项目模板 上面的项目不完整，不能满足我们的开发需要，所以需要我们手动建设一些文件夹，需要兴建的文件夹如下，以下是maven项目的标准目录结构：src&#x2F;main&#x2F;javasrc&#x2F;main&#x2F;resourcessrc&#x2F;test&#x2F;javasrc&#x2F;test&#x2F;resources下面来构建目录，在main上右击New-&gt;Directory 新建java文件夹和resources文件夹在src目录上右击New-&gt;Directory 新建test文件夹在test目录上右击New-&gt;Directory 新建java和resources文件夹下面只演示一个，其余类似 接下来就是把新建立的文件夹进行关联了，看清楚关联对象，关联错了就得重新关联，这一定不能出错，关联方法如下图。src&#x2F;main&#x2F;java 关联为 Sources Rootsrc&#x2F;main&#x2F;resources 关联为Resources Rootsrc&#x2F;test&#x2F;java 关联为Test Sources Rootsrc&#x2F;test&#x2F;resources 关联为 Test Resources Root 以下是关联之后完整的maven-web项目的目录，配置完成 二. 编写前端页面html，用户提交信息 acion对应创建的Serlvet类，method使用doPost方法（见第三部分java代码） 代码如下： 12345678910111213141516&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h1 style=color:green;size=&quot;20&quot;&gt;userinfo&lt;/h1&gt;&lt;br&gt; &lt;form action=&quot;LoginServlet&quot; method=&quot;post&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;&lt;br&gt; hometown: &lt;input type=&quot;text&quot; name=&quot;hometown&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 效果如图：（用户输入信息后点击Login登录） 三. 创建Serlvet类，并在main函数中嵌入Tomcat代码1. 在pom.xml中导入Servlet依赖，注意代码放在&lt;dependencys&gt;&lt;&#x2F;dependencys&gt;之间1234567891011121314&lt;!--加入servlet依赖（servlet的jar）--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;!--jsp的依赖（jsp相关的jar加进来）--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 2. 创建Serlvet类（LoginSerlvet）实现HttpServlet接口1234567891011121314151617181920212223242526import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException; //注意要导入Serlvet依赖import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;UTF-8&quot;); String username = req.getParameter(&quot;username&quot;); //对应html代码中input的name属性 String hometown = req.getParameter(&quot;hometown&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out=resp.getWriter(); System.out.println(&quot;用户名：&quot;+username); System.out.println(&quot;籍贯：&quot;+hometown); &#125;&#125; 3. 在pom.xml中导入Tomcat依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;9.0.12&lt;/version&gt; &lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-catalina --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt; &lt;version&gt;9.0.46&lt;/version&gt; &lt;/dependency&gt; 4. 建立一个测试类，在main函数中嵌入Tomcat代码 使用main函数启动，默认加载webapp下的index.jsp 1234567891011121314151617181920212223import org.apache.catalina.Context;import org.apache.catalina.WebResourceRoot;import org.apache.catalina.startup.Tomcat;import org.apache.catalina.webresources.DirResourceSet;import org.apache.catalina.webresources.StandardRoot;import java.io.File;public class Login &#123; public static void main(String[] args) throws Exception &#123; Tomcat tomcat = new Tomcat(); tomcat.setPort(Integer.getInteger(&quot;port&quot;, 8080)); tomcat.getConnector(); // 创建 WebApp Context context = tomcat.addWebapp(&quot;&quot;, new File(&quot;src/main/webapp&quot;).getAbsolutePath()); WebResourceRoot resources = new StandardRoot(context); resources.addPreResources( new DirResourceSet(resources, &quot;/WEB-INF/classes&quot;, new File(&quot;target/classes&quot;).getAbsolutePath(), &quot;/&quot;)); context.setResources(resources); tomcat.start(); tomcat.getServer().await(); &#125;&#125; 5. 配置web.xml文件，使tomcat启动时加载我们写好的html文件，配置Tomcat映射路径，使Serlvet类能获取页面信息。1234567891011121314&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; //与创建的Serlvet类同名 &lt;servlet-class&gt;LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;userinfo.html&lt;/welcome-file&gt; //加载我们编写的html文件 &lt;/welcome-file-list&gt;&lt;/web-app&gt; 四. 运行测试类的main函数，获取页面信息输入到后端 运行main函数，在地址栏输入locathost:8080&#x2F;userinfo.html（自己编写的html文件）访问前端页面，输入信息，点击Login登录。 可以看到控制台获取前端数据并输出： 至此我们成功获得前端数据并输出","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://yellowsy.github.io/tags/Java/"}]},{"title":"Windows XP驱动编程","slug":"Windows-XP驱动编程","date":"2022-09-18T14:58:59.000Z","updated":"2022-09-18T15:28:36.780Z","comments":true,"path":"2022/09/18/Windows-XP驱动编程/","link":"","permalink":"https://yellowsy.github.io/2022/09/18/Windows-XP%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/","excerpt":"","text":"简短操作系统驱动及安全 一. 配置和环境 系统windows XP 安装Windows SDK &amp; DDK 下载链接：Windows DDK 下载DriverMonitor.exe（将文件加载到内核） 下载DirverView.exe（观察驱动运行结果） 二. Windows XP平台下的驱动框架进行说明。1. Windows XP驱动框架。Windows XP驱动不同于普通的C应用态程序。C应用态程序的入口是main函数，但是驱动中没有main函数，Windows XP驱动入口函数称为“DriverEntry”的函数。在驱动加载后，第一个运行的就是DriverEntry函数，因此，所有需要初始化的工作都是在DriverEntry函数当中完成的。接下来，在初始化完成之后，DriverEntry（通过调用其他的功能函数）将控制权交给功能函数以完成必要的驱动功能。最后，当驱动工作完成之后，必须退出以释放内核空间，这是通过调用“驱动退出函数”实现的。与Windows XP驱动一定有一个固定的、称为“DriverEntry”的入口函数不同，“驱动退出函数”的名称是不定的，具体名称是什么，由“DriverEntry”中的“driver-&gt;DriverUnload”语句指定函数名。具体到本实验的例子（参见如下Encryption.c源码），有语句“driver-&gt;DriverUnload &#x3D; DriverUnload;”，因此在本例中，驱动的退出函数名为“DriverUnload”。 综上，Windows XP下的驱动框架部分需要掌握以下几点： 首先，驱动的入口函数称为“DriverEntry”，在“DriverEntry”中完成驱动的所有初始化工作； 之后，“DriverEntry”（通过调用其他功能函数）将控制权交给其他功能函数以完成驱动所需的功能。这个过程和用户态C语言的子函数调用是类似的； 最后，在“DriverEntry”使用“driver-&gt;DriverUnload &#x3D; XXXX;”语句指定驱动退出函数。上例中XXXX就是驱动退出函数的函数名，由用户进行编写后指定。当驱动程序退出时，会自动调用驱动退出函数以完成必要的终止和回收工作。 2. Windows驱动编译。驱动的编译可以采用DDK环境，也可以采用VC环境。本次实验采用DDK环境进行编译（感兴趣的同学可以搜索如何以VC6.0环境编译驱动。两者编译的结果是一样的，没有差别）。利用DDK环境编译驱动的具体过程如下： 首先在源程序的相同目录下创建两个文本文件makefile和Sources。这两个文本文件描述了DDK驱动程序的源文件、用到的lib文件、inlcude路径名以及编译输出的目录和文件名等信息，具体示例如下。 表1当中，第1行说明驱动的名称为Encrytion（驱动名根据需要修改）；第2行指明此驱动的类型为NT型驱动；第3行设置编译输出目录；第4行指定编译原文件名为Encryption.c（驱动源文件根据需要修改）。 Makefile文件内容如下： 编写完这两个脚本之后，在Windows的开始菜单中选择“Windows XP Checked Build Environment”编译环境，启动运行，进入到cmd命令界面。实验时选择Checked版本，而不是Free版本，两者的区别类似于Win32程序开发的Debug版本和Release版本。 最后，在进入命令行方式的cmd窗口之后，用cd命令进入需要编译的目录，然后输入“build”命令，DDK的编译环境就会自动调用编译器进行编译。如果编译出错，对应修改源文件即可；编译成功之后，会在obj目录中生成Encryption.sys文件。一旦成功生成了.sys文件，即可使用附带的instdrv.exe将驱动Encryption.sys加载到内核运行。 综上，Windows XP驱动编译需要掌握如下几点： Windows XP驱动可以采用DDK环境编译，也可以采用VC环境编译。两者的编译结果是一样的。 采用DDK环境编译时，需要在驱动程序所在的目录下创建makefile和Sources文件，具体的写法参见表1。 l驱动编译的结果是.sys文件。 3. Windows驱动安装与运行。Windows驱动编译生成.sys文件。.sys文件是不能直接运行的，必须要插入到内核当中。本实验当中，采用DriverMonitor.exe工具将其插入（当然选用其他工具也可以）。其步骤如下： 首先下载DriverMonitor.exe文件并安装到本机。 运行DriverMonitor.exe。点击”Edit“，添加文件。 打开编译得到的.sys文件。 4. 驱动信息查看。以上完成了驱动的加载，查看驱动运行信息（驱动中可以使用DbgPrint来打印一些信息，方便调试）可以采用DbgView.exe工具，运行之后，勾选“Capture Kernel”捕获内核信息即可。 以下是源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#define ENCRYPTION//#define DECRYPTION#include &lt;Ntddk.h&gt;NTSTATUS Encryption();VOID EnCode(PUCHAR pBuffer, SIZE_T bufferSize);VOID DeCode(PUCHAR pBuffer, SIZE_T bufferSize);VOID DriverUnload(PDRIVER_OBJECT driver); //Driver EntryNTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)&#123; HANDLE hfile; PUCHAR pBuffer; NTSTATUS ntStatus;/*#if DBG _asm int 3#endif*/ /* 内核打印需要使用DbgPrint函数。注意在内核中是不能使用应用态的库函数的， 因此，这里不能用printf，而只能使用内核专有的DbgPrint。 */ DbgPrint(&quot;Entering OS Kernel!\\r\\n&quot;); /* DbgPrint(&quot;The Driver name is: %wZ\\n&quot;, driver-&gt;DriverName); DbgPrint(&quot;The Driver size is: %ld\\n&quot;, driver-&gt;DriverSize); DbgPrint(&quot;The Driver start address: %x\\n&quot;, driver-&gt;DriverStart); */ ntStatus = Encryption(); //Driver Exit driver-&gt;DriverUnload = DriverUnload; return ntStatus;&#125;VOID DriverUnload(PDRIVER_OBJECT driver)&#123; DbgPrint(&quot;Leaving OS Kernel! Bye, Good luck!\\r\\n&quot;);&#125;//文件读写操作NTSTATUS Encryption()&#123; HANDLE hfile; OBJECT_ATTRIBUTES objectAttributes; IO_STATUS_BLOCK ioStatus; UNICODE_STRING logFileUnicodeString; NTSTATUS ntStatus; FILE_STANDARD_INFORMATION fsi; PUCHAR pBuffer, tempPBuffer; SIZE_T fileSize; WCHAR *file2En = L&quot;\\\\??\\\\D:\\\\TEDP_DEV\\\\TEST\\\\1.doc&quot;; //读取此文件内容，之后对其加密 WCHAR *enFile = L&quot;\\\\??\\\\D:\\\\TEDP_DEV\\\\TEST\\\\Encrypted.doc&quot;; //加密以后写入到此文件 //初始化要读取文件的UNICODE_STRING字符串 RtlInitUnicodeString(&amp;logFileUnicodeString, file2En); //RtlInitUnicodeString(&amp;logFileUnicodeString, &amp;fileName); //初始化要读取文件的objectAttributes InitializeObjectAttributes(&amp;objectAttributes, &amp;logFileUnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL); //打开要读取的文件 ntStatus = ZwCreateFile(&amp;hfile, GENERIC_READ, &amp;objectAttributes, &amp;ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(ntStatus)) &#123; KdPrint((&quot;Open read-file failed!\\n&quot;)); return ntStatus; &#125; else KdPrint((&quot;Open read-file successfully!\\n&quot;)); //查询要读取文件的相关信息，以便读取 ntStatus = ZwQueryInformationFile(hfile, &amp;ioStatus, &amp;fsi, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation); if (!NT_SUCCESS(ntStatus)) &#123; KdPrint((&quot;Query of read-file failed!\\n&quot;)); return ntStatus; &#125; //本来fsi.EndofFile.QuadPart是LONGLONG类型，但是，一个文件不会有64位大。32位已有4G，这里转为SIZE_T fileSize = (SIZE_T)fsi.EndOfFile.QuadPart; KdPrint((&quot;Totally %ld bytes will be read\\n&quot;, fileSize)); //为读取的文件分配缓冲区，在本程序中该缓冲区被释放 pBuffer = (PUCHAR)ExAllocatePoolWithTag(PagedPool, fileSize, &#x27;Tag1&#x27;); if (pBuffer == NULL) &#123; KdPrint((&quot;Allocation memory for reading file failed!\\n&quot;)); return ntStatus; //? &#125; else tempPBuffer = pBuffer; //读取文件内容 ntStatus = ZwReadFile(hfile, NULL, NULL, NULL, &amp;ioStatus, pBuffer, fileSize, NULL, NULL); if (!NT_SUCCESS(ntStatus)) &#123; KdPrint((&quot;Open read-file failed!\\n&quot;)); ZwClose(hfile); ExFreePool(pBuffer); return ntStatus; &#125; KdPrint((&quot;Finally %ld bytes were read\\n&quot;, ioStatus.Information)); //关闭被读取的文件 ZwClose(hfile); //写入加密文件 //初始化加密文件的UNICODE_STRING字符串 RtlInitUnicodeString(&amp;logFileUnicodeString, enFile); //RtlInitUnicodeString(&amp;logFileUnicodeString, &amp;fileName); //初始化objectAttributes InitializeObjectAttributes(&amp;objectAttributes, &amp;logFileUnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL); //打开写文件以便写 ntStatus = ZwCreateFile(&amp;hfile, GENERIC_WRITE, //准备写文件 &amp;objectAttributes, &amp;ioStatus, NULL, //没有指定初始化分配的文件空间大小 FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, //其他进程不能写该文件 FILE_OPEN_IF, //创建文件，如果文件已存在的话，则清空打开 FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(ntStatus)) &#123; KdPrint((&quot;Open write-file failed!\\n&quot;)); ExFreePool(pBuffer); return ntStatus; &#125; KdPrint((&quot;Create file successfully!\\n&quot;)); //对pBuffer的内容进行加密#ifdef ENCRYPTION EnCode(pBuffer, fileSize);#endif //开始写入文件 ntStatus = ZwWriteFile(hfile, NULL, NULL, NULL, &amp;ioStatus, pBuffer, fileSize, NULL, NULL); if (!NT_SUCCESS(ntStatus)) &#123; KdPrint((&quot;Write to write-file failed!\\n&quot;)); ExFreePool(pBuffer); ZwClose(hfile); return ntStatus; &#125; else &#123; KdPrint((&quot;Write to write-file successfully!\\n&quot;)); ExFreePool(pBuffer); ZwClose(hfile); return ntStatus; &#125;&#125;//加密操作。需要替换为DES加密函数VOID EnCode(PUCHAR pBuffer, SIZE_T bufferSize)&#123; int index = 0; while(index++ != bufferSize) &#123; *pBuffer ^= &#x27;z&#x27;; pBuffer++; &#125;&#125;//解密操作。需要替换为DES解密函数VOID DeCode(PUCHAR pBuffer, SIZE_T bufferSize)&#123; int index = 0; while(index++ != bufferSize) &#123; *pBuffer ^= &#x27;z&#x27;; pBuffer++; &#125;&#125; （1）将上述驱动编译成功。使用 Windows XP x86 Checked Build Enviroment进行编译： 编译后产生的sys文件（系统文件）： （2）将编译成功的驱动插入到内核运行，并观察运行结果。使用DriverMonitor.exe将sys文件加载到内核运行： 然后使用DirverView.exe观察驱动运行结果： 原文件内容： 加密后的文件：","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yellowsy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"进程间通信","slug":"进程间通信","date":"2022-09-18T14:26:04.000Z","updated":"2022-09-18T14:51:10.049Z","comments":true,"path":"2022/09/18/进程间通信/","link":"","permalink":"https://yellowsy.github.io/2022/09/18/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"一、 进程间通信机制说明linux下多个进程间的通信机制叫做IPC，它是多个进程之间相互沟通的一种方法。在linux下有多种进程间通信的方法：半双工管道、命名管道、消息队列、信号、信号量、共享内存、内存映射文件，套接字等等。 二、 进程间通信方法说明2.1 半双工管道方法说明（1）管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用fork后，这个管道就能在父子进程间使用了。 （2）管道通过pipe(int fd[2])函数创建，参数fd[0]为读而打开，fd[1]为写而打开。fd[1]的输出是fd[0]的输入。简单来说，当父进程打开fd[1]关闭fd[0],就可以向管道写入文件，而子进程打开fd[0]关闭fd[1],可以从管道中读取文件。 2.2 命名管道方法说明命名管道又称FIFO,它是一种特殊类型的文件，它在系统中以文件形式存在。未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是，通过FIFO,不相关的进程也能交换数据。我们可以使用mkfifo或者mkfifoat创建FIFO,然后用opne来打开它。如果命名管道FIFO打开时设置了读权限，则读进程将一直阻塞，一直到其他进程打开该FIFO并向管道写入数据。 2.3 消息队列方法说明消息队列是消息的链接表，储存在内核中，由消息队列标识符标识。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。 msgget创建一个新队列或打开一个存在的队列；msgsnd向队列末端添加一条新消息；msgrcv从队列中取消息， 取消息是不一定遵循先进先出的， 也可以按消息的类型字段取消息。 2.4 共享储存方法说明共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过内存读读出其中的消息内容，从而实现了进程间的通信。通过shmget创建一个共享内存段，并获得一个进程标识符。然后通过shmat将其连接到它的地址空间，shmat的返回值是该段所连接的实际地址。可以通过指针指向该地址对其中内容进行操作。 三、 同步互斥方法实现3.1 半双工管道方法实现3.1.1 半双工管道示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;sys/types.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#define BUFFER_SIZE 25#define READ_END 0#define WRITE_END 1int main()&#123; char write_msg[BUFFER_SIZE]=&quot;Greetings\\n&quot;;//要写入的信息 char read_msg[BUFFER_SIZE];//存放读取文件 int fd[2]; pid_t pid; if(pipe(fd)==-1) &#123; fprintf(stderr,&quot;Pipe failed&quot;); return 1; &#125; pid=fork(); if(pid&lt;0) &#123; fprintf(stderr,&quot;Fork failed&quot;); return 1; &#125; if(pid&gt;0)//父进程，向管道写入信息 &#123; close(fd[READ_END]);//关闭读出端 /*从write_msg中写入数据到fd[WRUTE_END]中，并指定写入数据长度*/ write(fd[WRITE_END],write_msg,strlen(write_msg)+1); close(fd[WRITE_END]); &#125; else//子进程，向管道读取信息 &#123; close(fd[WRITE_END]); //关闭写入端 /*从fd[READ_END]中读取数据到read_msg中*/ read(fd[READ_END],read_msg,BUFFER_SIZE); printf(&quot;read:%s&quot;,read_msg); close(fd[READ_END]); &#125; return 0;&#125; 编译及运行结果： 3.1.2半双工管道关键代码说明（1）父进程关闭读出端，通过write函数从write_msg中写入数据到fd[WRUTE_END]中 close(fd[READ_END]); write(fd[WRITE_END],write_msg,strlen(write_msg)+1); （2）子进程关闭写入端，通过read函数从fd[READ_END]中读取数据到read_msg中，然后输出到标标准输出。 close(fd[WRITE_END]); read(fd[READ_END],read_msg,BUFFER_SIZE); 3.2 命名管道方法实现3.2.1 命名管道示例代码服务端代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/stat.h&gt;#include&lt;linux/stat.h&gt;#define FIFO_FILE &quot;MYFIFO&quot;int main()&#123; FILE *fp;//文件指针 char readbuf[80]; /*创建命名管道MYFIFO*/ mkfifo(&quot;MYFIFO&quot;,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); while(1) &#123; /*打开命名管道*/ if((fp=fopen(FIFO_FILE,&quot;r&quot;))==NULL) &#123; printf(&quot;open fifo failed\\n&quot;); exit(1); &#125; /*从命名管道中读取数据*/ if(fgets(readbuf,80,fp)!=NULL) &#123; printf(&quot;Received string : %s\\n&quot;,readbuf); fclose(fp); &#125; else &#123; if(ferror(fp)) &#123; printf(&quot;read fifo failed\\n&quot;); exit(1); &#125; &#125; &#125; return 0;&#125; 客户端代码：123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define FIFO_FILE &quot;MYFIFO&quot;int main(int argc,char *argv[])&#123; FILE *fp; int i; if(argc&lt;=1) &#123; printf(&quot;usage : %s &lt;pathname&gt;\\n&quot;,argv[0]); exit(1); &#125; if((fp=fopen(FIFO_FILE,&quot;w&quot;))==NULL) &#123; printf(&quot;open fifo failed\\n&quot;); exit(1); &#125; for(i=1;i&lt;argc;i++)//读取命名行参数作为输入数据 &#123; if(fputs(argv[i],fp)==EOF) &#123; printf(&quot;write fifo error\\n&quot;); exit(1); &#125; if(fputs(&quot; &quot;,fp)==EOF) &#123; printf(&quot;write fifo error\\n&quot;); exit(1); &#125; &#125; fclose(fp); return 0;&#125; 首先启动客户端，进入阻塞状态等待客户端的输入。 然后启动客户端，写入数据到管道中。 服务端从中读取数据，显示到屏幕。 3.2.2 命名管道关键代码说明(1)创建一个命名管道： mkfifo(“MYFIFO”,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); 参数 S_IWUSR：用户写权限 ​ S_IRUSR：用户读权限 ​ S_IRGRP：用户组读权限 ​ S_IROTH：其他组读权限 （2）服务端： fp指向以可读形式打开的管道文件，并从中读取数据到readbuf中，然后显示到屏幕。 fp&#x3D;fopen(FIFO_FILE,”r”) fgets(readbuf,80,fp) （3）客户端： fp指向以可写形式打开的管道文件，并将命令行参数写入到管道文件中，以便服务端读取。 fp&#x3D;fopen(FIFO_FILE,”w”) for(i&#x3D;1;i&lt;argc;i++) fputs(argv[i],fp； 3.3 消息队列方法实现3.3.1 消息队列示例代码发送消息代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/msg.h&gt; struct my_msg&#123; long int my_msg_type; char text[BUFSIZ];&#125;msgbuf;int main()&#123; int running=1; int msgid; long int msg_to_receive=0; msgid=msgget((key_t)1028,0666|IPC_CREAT);//创建引用标识符为1028的消息队列 if(msgid==-1) &#123; printf(&quot;magget failed\\n&quot;); exit(1); &#125; while(running) &#123; printf(&quot;请输入你想写的信息：&quot;); fflush(stdin);//过滤掉最后的enter(换行符) fgets(msgbuf.text,BUFSIZ,stdin); msgbuf.my_msg_type=1; /*发送消息;第二个参数是一个指向长整数的指针，其后紧接着的是消息数据*/ if(msgsnd(msgid,(void*)&amp;msgbuf,BUFSIZ,0)==-1) &#123; printf(&quot;magsnd failed\\n&quot;); exit(1); &#125; if(strncmp(msgbuf.text,&quot;end&quot;,3)==0) running=0; &#125; return 0;&#125; 接收消息代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/msg.h&gt;struct my_msg&#123; long int my_msg_type; char text[BUFSIZ];&#125;msgbuf; int main()&#123; int running=1; int msgid; long int msg_to_receive=0; msgid=msgget((key_t)1028,0666|IPC_CREAT);//创建我们想打开的的消息队列 if(msgid==-1) &#123; printf(&quot;magget failed\\n&quot;); exit(1); &#125; while(running) &#123; /*接受消息，将它赋值到结构体的地址空间*/ if(msgrcv(msgid,(void*)&amp;msgbuf,BUFSIZ,msg_to_receive,0)==-1) &#123; printf(&quot;magrcv failed\\n&quot;); exit(1); &#125; printf(&quot;你写入信息是：%s&quot;,msgbuf.text); /*比较两个字符串，指定长度为3; 即输入end就结束*/ if(strncmp(msgbuf.text,&quot;end&quot;,3)==0) running=0; &#125; /*msgctl删除队列(cmd参数指定为IPC_RMID)*/ if(msgctl(msgid,IPC_RMID,0)==-1) &#123; printf(&quot;msgct(IPC_RMID) failed\\n&quot;); exit(1); &#125; return 0;&#125; 运行结果：发送方发送消息（不需要先运行接受方程序） 接收方接收消息： 3.3.2 消息队列关键代码说明（1）创建消息队列：msgid&#x3D;msgget((key_t)1028,0666|IPC_CREAT) (2) 用户从键盘输入数据，并将数据放到消息队列中： fgets(msgbuf.text,BUFSIZ,stdin); msgsnd(msgid,(void*)&amp;msgbuf,BUFSIZ,0) （3）从队列中取用消息，将它赋值到结构体的地址空间： msgrcv(msgid,(void*)&amp;msgbuf,BUFSIZ,msg_to_receive,0) 第四个参数type即msg_to_receive指定想要哪一种消息。 type&#x3D;&#x3D;0返回队列中的第一个消息 type&gt;0返回队列中的消息类型为type的第一个消息 tyoe&lt;0返回队列中消息类型值小于等于绝对值的消息，如果消息有若干个，则取类型值最小的消息 3.4 共享储存方法实现3.4.1 共享储存示例代码服务进程：12345678910111213141516171819202122232425262728293031323334353637#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main()&#123; int shmid; char c; char *shmptr,*s; /*创建一个名为&quot;1234&quot;的共享内存,返回值为共享内存的进程标识符*/ if((shmid=shmget(1234,256,IPC_CREAT|0666))&lt;0)&#123; printf(&quot;shmget failed\\n&quot;); exit(1); &#125; /*将共享内存附加到自己的地址空间上*/ if((shmptr=shmat(shmid,0,0))==(void*)-1)&#123; /*指定参数IPC_RMID，用于删除共享内存*/ shmctl(shmid,IPC_RMID,(void*)shmptr); printf(&quot;shmat failed\\n&quot;); exit(1); &#125; s=shmptr; for(c=&#x27;a&#x27;;c&lt;=&#x27;z&#x27;;c++) &#123; *s++=c; &#125; *s=NULL; while(*shmptr!=&#x27;*&#x27;)//等待客户端读完数据 sleep(1); shmctl(shmid,IPC_RMID,(void*)shmptr); return 0;&#125; 客户进程：1234567891011121314151617181920212223242526272829#include&lt;sys/types.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; int main()&#123; int shmid; char c; char *shmptr,*s; if((shmid=shmget(1234,256,0666))&lt;0) &#123; printf(&quot;shmget failed\\n&quot;); exit(1); &#125; if((shmptr=shmat(shmid,0,0))==(void*)-1) &#123; shmctl(shmid,IPC_RMID,(void*)shmptr); printf(&quot;shmat failed\\n&quot;); exit(2); &#125; for(s=shmptr;*s!=NULL;s++) putchar(*s); printf(&quot;\\n&quot;); *shmptr=&#x27;*&#x27;; return 0;&#125; 服务进程开启等待客户读取完数据： 客户读取数据： 客户读取完数据之后服务器进程关闭： 3.4.2 共享储存关键代码说明服务端进程：创建标识符为1234的共享内存，并用shmprt指向它返回的实际地址空间 shmid&#x3D;shmget(1234,256,IPC_CREAT|0666) shmptr&#x3D;shmat(shmid,0,0) 向其中写入数据后等待客户读取完数据并删除该共享内存段 while(shmptr!&#x3D;’‘)&#x2F;&#x2F;等待客户端读完数据 sleep(1); shmctl(shmid,IPC_RMID,(void*)shmptr); 客户端进程：打开该共享内存，并用shmprt指向它返回的实际地址空间 shmid&#x3D;shmget(1234,256,0666) shmptr&#x3D;shmat(shmid,0,0) 然后读取共享内存段里面的内容，并将共享内存里面的内容设置为’*’,告诉服务进程已经读取完毕 for(s&#x3D;shmptr;*s!&#x3D;NULL;s++) putchar(*s); *shmptr&#x3D;’*‘;","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yellowsy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"Typora图片上传到博客","slug":"Typora图片上传到博客","date":"2022-09-18T06:55:06.000Z","updated":"2022-09-18T13:40:28.892Z","comments":true,"path":"2022/09/18/Typora图片上传到博客/","link":"","permalink":"https://yellowsy.github.io/2022/09/18/Typora%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"使用Typota上传图片到博客的方法 一. 使用插件hexo-asset-image1. 修改配置文件 首先修改blog(存放博客文件的目录)文件下的_config.yml文件，设置post_asset_folder这个选项为true, 目的是在新建文章时会在_psots文件夹下自动生成一个同名的文件夹，用来存放上传的图片。 2. 设置Typora的图像配置 设置图像复制到指定路径，文件地址：.&#x2F;${filename} 3. 安装hexo-asset-image插件 注意 不要使用npm install hexo-asset-image --save这个命令安装,版本号不对,上传图片路径会有问题，使用以下命令 进入blog目录下，打开Git push,输入命令： npm install https://github.com/CodeFalling/hexo-asset-image --save 或者下载hexo-asset-image-for-hexo5插件： npm install hexo-asset-image-for-hexo5 --save 插件地址：hexo-asset-image-for-hexo5 4. 最后便可在typora中插入图片上传到博客显示二. 使用PicGo + GitHub 搭建个人图床工具1.GitHub 仓库设置流程：新建 public 仓库 -&gt; 创建 token -&gt; 复制 token 备用1.1 新建仓库 点击 git 主页右上角的 + 创建 New repository； 填写仓库信息，例如我就创建了一个 cloudimg 的仓库。这里注意，仓库得设置为 Public 因为后面通过客户端访问算是外部访问，因此无法访问 Private ，这样的话图片传上来之后只能存储不能显示。所以要设置为 Public。 1.2 创建 token 并复制保存 此时仓库已经建立，点击右上角头像，然后进入设置； 在页面最下找到 Developer settings，点击进入； 创建 token； 填 description（也是随心填），勾选复选框 repo ，接着到页面底部 Generate token 就完成了； 然后复制生成一串字符 token，这个 token 只出现一次，所以要保存一下。(一定要记好) 2. PicGo 客户端配置2.1 下载&amp;安装 PicGo （下载最新版就行）是一个开源的图床工具，非常优秀。可以到 git 上下载。 下载地址：Picgo 2.2 配置 图床配置，设置Githu图床 设置监听端口为36677（不是的话要修改为36677） 最后便可以上传图片了，注意这里要设置为Github图床。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yellowsy.github.io/tags/Hexo/"}]},{"title":"进程的同步互斥","slug":"进程的同步互斥","date":"2022-09-14T16:28:12.000Z","updated":"2022-09-18T14:29:32.992Z","comments":true,"path":"2022/09/15/进程的同步互斥/","link":"","permalink":"https://yellowsy.github.io/2022/09/15/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/","excerpt":"","text":"一、 引起同步互斥问题的原因同步：因为一些任务不是有一个进程实现，而是通过多个进程共同实现，所以这些进程之间按照一定的规则，互相协调合作共同实现某一任务而进行同步。 互斥：因为在多个程序并发执行时，由于共享系统资源，对于临界资源，多个进程只能进行互斥的访问，即每次只能允许一个进程访问，所以这些进程对于该资源的访问就形成了相互制约的关系。 二、 同步互斥方法说明2.1 互斥锁同步互斥方法说明当多个线程对公共资源进行访问和写入时，加上互斥锁以保证数据不会被多个线程操作时而混乱。下面以简单读，写操作来说明。一个线程从共享的缓冲区中读取操作，另一个线程向缓冲区中写数据，保证不会对共享缓冲区同时读取和写入，对共享缓冲区的访问加上互斥锁实现。通过线程函数pthread_create()在主进程中创建两个线程，一个进行读取，另一个进行写入，如果缓冲区为空，那么就向缓冲区中写入数据，并将buffer_has_sem设置为1，让读线程可以读取数据。读线程则先判断缓冲区是否为空，不为空为输出数据。 2.2 条件变量同步互斥方法说明条件变量是对互斥锁的补充，它的作用是用于多线程之间关于共享数据状态变化的通信，它允许线程阻塞并等待另一个线程发送的信号。当收到信号时，阻塞的线程就被唤醒并试图锁定与之相关的互斥锁。以哲学家就餐例子说明。哲学家拿到左右的两只筷子就可以开始吃饭，吃完饭放下筷子思考，利用互斥锁和条件变量进行同步互斥。因为对筷子数量的访问属于临界资源访问，所以对i号哲学家拿筷子进行上锁，拿完后便开锁。当i号哲学家拿不到左右两只筷子时，便通过条件变量开始等待，其他哲学吃完放下筷子后可以发送信号给该哲学家，当他再次发现筷子可用时便开始吃饭。以通信的方式来实现两者的同步互斥。 2.3 信号量同步互斥方法说明信号量是一个用于表示资源数目的整型量S，它仅能通过两个标准的原子操作wait(S)和signal(S)来访问，它是具有一个等待队列的计数器，属于临界资源的一种，要获取信号量资源，则对信号量进行-1操作，要释放信号量资源，则对信号量资源进行+1操作。以读者写者问题进行说明。读和写操作不能同时进行。允许多个读者同时读取数据，通过设置rw_mutex信号量来实现读写进程的互斥访问，read_cound来统计读者的数量，mutex用于对read_cound同步互斥的访问。一旦一个读者获得了读锁，其他的读者也可以获取这个读锁。但是，想要获取写锁的线程，就必须等到所有的读者都结束。 2.4 屏障同步互斥方法说明 屏障是用户协调多个线程并行工作的同步机制。当线程到达屏障点时，它不能继续，直到所有其他的线程也已经到这一点。当最后的线程到达屏障点时，所有线程被释放，并且能够恢复并发执行。使用pthread_barrier_init()函数对屏障进行初始化，使用count参数指定，在允许所有线程继续运行之前，必须到达屏障的线程数目。使用pthread_barrier_wait()函数来表明，线程已工作完成，准备等所有其他线程赶上来。以选手评分例子说明。在主线程中创建3个子线程，一个求最高分，另一个求最低分，最后一个线程去掉最高分和最低分后求其平均值，该线程在求最后平均分时必须要等到另外两个子线程求出最高分和最低分。求出的最后得分在主线程中输出。 三、 同步互斥方法实现3.1互斥锁同步互斥方法实现3.1.1 互斥锁同步互斥示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#define FALSE 0#define TRUE 1char buffer[256];//定义共享缓冲区int buffer_has_item=0;//判断缓冲区是否有数据int retflag=FALSE;pthread_mutex_t mutex;//定义互斥锁void readfun()&#123; while(1) &#123; if(retflag) return; pthread_mutex_lock(&amp;mutex);//对读操作进行上锁 if(buffer_has_item==1) &#123; printf(&quot;reader：%s\\n&quot;,buffer); buffer_has_item=0; &#125; pthread_mutex_unlock(&amp;mutex);//对读操作进行开锁 &#125;&#125;void writefun()&#123; int i=0; while(1) &#123; if(i==5)//写入5个数据就退出 &#123; retflag=TRUE; return; &#125; pthread_mutex_lock(&amp;mutex);//对写入操作进行上锁 if(buffer_has_item==0) &#123; printf(&quot;writer：%c\\n&quot;,i+’a’); sprintf(buffer,&quot;%c&quot;,i+’a’); buffer_has_item=1; &#125; pthread_mutex_unlock(&amp;mutex);//对写入操作进行开锁 &#125;&#125;int main()&#123; //定义两个线程ID pthread_t reader; pthread_t writer; pthread_mutex_init(&amp;mutex,NULL);//初始化互斥锁 //创建两个子线程 pthread_create(&amp;reader,NULL,(void*)&amp;readfun,NULL); pthread_create(&amp;writer,NULL,(void*)&amp;writefun,NULL); //等待两个子线程结束 pthread_join(reader,NULL); pthread_join(writer,NULL); return 0;&#125; 编译后运行： 运行结果： 3.1.2 互斥锁同步互斥关键代码说明（1）函数说明： ​ pthread_mutex_inti(&amp;mutex,NULL); &#x2F;&#x2F;初始化互斥锁 ​ pthread_mutex_lock(&amp;mutex); &#x2F;&#x2F;上锁 ​ pthread_mutex_unlock(&amp;mutex); &#x2F;&#x2F;开锁 ​ pthread_join(reader,NULL); &#x2F;&#x2F;等待写入线程结束 ​ pthread_join(writer,NULL);&#x2F;&#x2F;等待读取线程结束 （2）临界区资源buffer_has_item ​ if(buffer_has_item&#x3D;&#x3D;1){ ​ printf(“read：%s\\n”,buffer); ​ buffer_has_item&#x3D;0; ​ } ​ if(buffer_has_item&#x3D;&#x3D;0){ ​ printf(“write：%c\\n”,i+’a’); ​ sprintf(buffer,”%c”,i+’a’); ​ buffer_has_item&#x3D;1; ​ } 3.2互斥锁同步互斥方法实现3.2.1 条件变量同步互斥示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#define N 6int philosopher_num=0;//定义想吃的哲学家的数量int chopstick[N]=&#123;1,1,1,1,1,1&#125;;//初始化筷子数量pthread_mutex_t mutex;//定义对拿筷子的互斥访问pthread_mutex_t num;//定义对philosopher_num的互斥访问pthread_cond_t cond_Var;//定义条件变量 void pick_forks(int i)&#123; pthread_mutex_lock(&amp;num);//对临界资源上锁 philosopher_num++; printf(&quot;%d号哲学家想吃饭，共有%d个哲学家想吃饭\\n&quot;,i,philosopher_num); pthread_mutex_unlock(&amp;num);&#125;void return_forks(int i)&#123; pthread_mutex_lock(&amp;num);//对临界资源上锁 philosopher_num--; pthread_mutex_unlock(&amp;num); printf(&quot;%d号哲学家已吃完开始思考\\n&quot;,i);&#125;void* philosopher(void* arg)&#123; int i=*(int*)arg;//哲学家编号 pick_forks(i); pthread_mutex_lock(&amp;mutex); while(chopstick[i]==0||chopstick[(i+1)%N]==0) pthread_cond_wait(&amp;cond_Var,&amp;mutex);//判断i号哲学家左右两边是否有筷子，如果没有就等待 chopstick[i]--; chopstick[(i+1)%N]--; printf(&quot;%d eating\\n&quot;,i);//哲学家拿到筷子便开始吃饭 pthread_mutex_unlock(&amp;mutex); pthread_mutex_lock(&amp;mutex); chopstick[i]++; chopstick[(i+1)%N]++; return_forks(i);//哲学家吃完饭放下筷子开始思考 pthread_cond_signal(&amp;cond_Var);//i号哲学家吃完，告诉其他哲学家筷子可用 pthread_mutex_unlock(&amp;mutex); pthread_exit(0);&#125;int main(int argc,char* argv[])&#123; int i,arr[N]=&#123;0,1,2,3,4,5&#125;;//定义哲学家编号 pthread_mutex_init(&amp;mutex,NULL); pthread_mutex_init(&amp;num,NULL); pthread_cond_init(&amp;cond_Var,NULL); pthread_t phil[N]; for(i=0;i&lt;N;i++) &#123; pthread_create(phil+i,NULL,(void*)&amp;philosopher,&amp;arr[i]);//创建六个哲学家线程 &#125; for(i=0;i&lt;N;i++)//等待子线程结束 &#123; pthread_join(phil[i],NULL); &#125; return 0;&#125; 编译并执行： 执行结果： 3.2.2 条件变量同步互斥关键代码说明（1）想吃饭的哲学家数量为临界资源，对其进行上锁 ​ pthread_mutex_lock(&amp;num);&#x2F;&#x2F;对临界资源上锁​ philosopher_num–;​ pthread_mutex_unlock(&amp;num); （2）哲学家进行吃饭时，通过pthread_mutex_lock(&amp;mutex)对哲学家访问筷子临界资源进行上锁。当拿不到左右筷子时进行等待。while循环是为了被唤醒后继续进行条件判断。当条件满足时wait()将线程阻塞后会释放互斥锁lock,以便其他进程能访问共享变量。别唤醒后进行上锁，以免其他线程进入。 ​ pthread_mutex_lock(&amp;mutex); ​ while(chopstick[i]&#x3D;&#x3D;0||chopstick[(i+1)%N]&#x3D;&#x3D;0) pthread_cond_wait(&amp;cond_Var,&amp;mutex); chopstick[i]–; chopstick[(i+1)%N]–; printf(“%d eating\\n”,i);&#x2F;&#x2F;哲学家拿到筷子便开始吃饭 pthread_mutex_unlock(&amp;mutex); （3）哲学家吃完饭，放下筷子然后通过pthread_cond_signal(&amp;cond_Var)发送信号告诉其他哲学家他左右两边筷子可用，让等待的线程可以继续运行 pthread_mutex_lock(&amp;mutex); chopstick[i]++; chopstick[(i+1)%N]++; return_forks(i);&#x2F;&#x2F;哲学家吃完饭放下筷子开始思考 pthread_cond_signal(&amp;cond_Var);&#x2F;&#x2F;i号哲学家吃完告诉其他哲学家筷子可用 pthread_mutex_unlock(&amp;mutex); 3.3 信号量同步互斥方法实现3.3.1 信号量同步互斥示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;sem_t rw_mutex;//用于对读写进程互斥的访问sem_t mutex;//用于对read_count变量同步互斥的访问int read_count=0; void* reading(void* arg)&#123; sem_wait(&amp;mutex);//对临界资源read_count进行上锁 read_count++; if (read_count==1)//第一个读者拿到锁后，其他读者可以直接进入 sem_wait(&amp;rw_mutex); sem_post(&amp;mutex); printf(&quot;%d号读者正在读取数据！\\n&quot;,*(int*)arg); sem_wait(&amp;mutex); read_count--; if(read_count==0)//最后一个读者释放锁 sem_post(&amp;rw_mutex); sem_post(&amp;mutex); pthread_exit(0);&#125; void* writing(void* arg)&#123; while(1) &#123; sem_wait(&amp;rw_mutex);//争夺互斥量，与读进程进行互斥的访问 printf(&quot;正在写入数据！\\n&quot;); sem_post(&amp;rw_mutex); sleep(2); &#125;&#125;int main()&#123; int i,reader_id[5]=&#123;1,2,3,4,5&#125;;//定义读者编号 sem_init(&amp;rw_mutex,0,1); sem_init(&amp;mutex,0,1); pthread_t reader[5],writer; //创建写者线程 pthread_create(&amp;writer,NULL,(void*)&amp;writing,NULL); //创建5个读者线程 for(i=0;i&lt;5;i++) &#123; pthread_create(reader+i,NULL,(void*)&amp;reading,&amp;reader_id[i]); sleep(1); &#125; //等待读者线程结束，写线程中有while循环，不用等待它结束 for(i=0;i&lt;5;i++) &#123; pthread_join(reader[i],NULL); &#125; sem_destroy(&amp;rw_mutex); sem_destroy(&amp;mutex); return 0;&#125; 编译后执行： 运行结果： 3.3.2 信号量同步互斥关键代码说明（1）对读者线程，首先对read_count临界资源上锁，并将读者数量加1，如果是第一个读者拿到锁，那么其他读者不再需要与写者进行争夺锁便可以读取数据。 当剩最后一个读者时，读完数据后将读&#x2F;写进程锁释放。*(int*)arg为线程(读者)编号。 sem_wait(&amp;mutex); read_count++; if (read_count&#x3D;&#x3D;1) sem_wait(&amp;rw_mutex); sem_post(&amp;mutex); printf(“%d号读者正在读取数据！\\n”,(int)arg); sem_wait(&amp;mutex); read_count–; if(read_count&#x3D;&#x3D;0) sem_post(&amp;rw_mutex); sem_post(&amp;mutex); （2）写者进程通过while循环一直进行写操作,争躲到读&#x2F;写进程锁就可以进行数据写入 ​ while(1) ​ { ​ sem_wait(&amp;rw_mutex); ​ printf(“正在写入数据！\\n”); ​ sem_post(&amp;rw_mutex); ​ } （3）sem_post( ) 函数（函数原型 int sem_wait(sem_t * sem);） 作用是给信号量的值加上一个“1”。 当有线程阻塞在这个信号量上时，调用这个函数会使其中一个线程不在阻塞，选择机制是有线程的调度策略决定的。 ​ sem_wait ( ) 函数（函数原型 int sem_wait(sem_t * sem);）它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。 3.4屏障同步互斥方法实现3.4.1 屏障同步互斥示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#define N 7 pthread_barrier_t barrier;//定义屏障double ave;//平均分int min,max;//最低分和最高分//计算去掉最低分和最高分之后的平均分void* average(int *arg)&#123; int i,sum=0; for(i=0;i&lt;N;i++) &#123; sum+=arg[i]; &#125; /*等待两个子线程找出最低分和最高分后，然后再来求平均分*/ pthread_barrier_wait(&amp;barrier);//到达屏障点,停止等待 /*等所有线程到达屏障点后,继续运行求出平均值在主线程中输出*/ ave=(sum-min-max)/(N-2.0); pthread_exit(0);&#125;//找到最低分void* mininum(int *arg)&#123; int i,j; min=arg[0]; for(i=0;i&lt;N;i++) &#123; if(arg[i]&lt;min) &#123; min=arg[i]; &#125; &#125; printf(&quot;The mininum value is %d\\n&quot;,min); pthread_barrier_wait(&amp;barrier);//到达屏障点,停止等待 pthread_exit(0);&#125;//找到最高分void* maxinum(int *arg)&#123; int i,j; max=arg[0]; for(i=0;i&lt;N;i++) &#123; if(arg[i]&gt;max) &#123; max=arg[i]; &#125; &#125; printf(&quot;The maxinum value is %d\\n&quot;,max); pthread_barrier_wait(&amp;barrier);//到达屏障点,停止等待 pthread_exit(0);&#125; int main(int argc,char* argv[])&#123; if(argc!=8) &#123; printf(&quot;请输入%d个数值\\n&quot;,N); return 0; &#125; int i,array[N]; for(i=0;i&lt;N;i++)//将命令行输入的参数存入数组中 &#123; array[i]=atoi(argv[i+1]); &#125; pthread_t tid1,tid2,tid3; /*初始化屏障，设置需到达屏障的数目为3(3个子线程)*/ pthread_barrier_init(&amp;barrier,NULL,4); pthread_create(&amp;tid1,NULL,(void*)&amp;average,array); pthread_create(&amp;tid2,NULL,(void*)&amp;maxinum,array); pthread_create(&amp;tid3,NULL,(void*)&amp;mininum,array); pthread_join(tid1,NULL);//等待tid1线程求出平均值，以免主线程先结束 printf(&quot;The final score is %.1f\\n&quot;,ave); pthread_barrier_destroy(&amp;barrier);//释放屏障资源 return 0;&#125; 编译代码： 运行结果： 3.4.2 屏障同步互斥关键代码说明 （1）对于求平均分线程，要等待两个子线程找出最低分和最高分后，才能求最后的得分。 通过设置屏障，等待其他线程到达该点后，继续并发执行求出最后的平均分ave。最后在主线程中输出平均分。 ​ for(i&#x3D;0;i&lt;N;i++) ​ { ​ sum+&#x3D;arg[i]; &#125; ​ pthread_barrier_wait(&amp;barrier);&#x2F;&#x2F;到达屏障点,停止等待 ​ ave&#x3D;(sum-min-max)&#x2F;(N-2.0); (2)对于另外两个子线程，当求出最大值和最小值后，表明自己的工作已经完成。并输出最大值和最小值。 ​ printf(“The maxinum value is %d\\n”,max); ​ pthread_barrier_wait(&amp;barrier); ​ printf(“The maxinum value is %d\\n”,max); ​ pthread_barrier_wait(&amp;barrier);","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yellowsy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"Web静态网页","slug":"Web静态网页","date":"2022-09-14T09:46:03.000Z","updated":"2022-10-12T14:14:57.356Z","comments":true,"path":"2022/09/14/Web静态网页/","link":"","permalink":"https://yellowsy.github.io/2022/09/14/Web%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/","excerpt":"","text":"1. 猜数游戏 用户点击开始，在0-100内随机生成一个整数，输入你想猜的数字，点击提交。 演示界面： 猜数游戏-演示地址 2. 照亮黑暗 用户鼠标在页面停留，界面以用户的鼠标为中心形成光圈。 演示界面： ​ 照亮黑暗-演示地址 3.碰撞小球 用户可以点击小球并划动它，使它们相互碰撞。 演示界面： ​ 碰撞小球-演示地址 4.电影购票 用户点击选座位，侧栏显示对应座位信息，也可以取消已选择的座位，则删除对应的座位信息，点击下单，显示付款金额，最多可购选五张票。 演示界面： 电影购票-演示地址 5.加载进度动画 演示界面： 加载进度动画-演示地址 6.简约的登录界面 一个酷炫的用户登录界面。 演示界面： ​ 简约的登录界面-演示地址 7.转动时钟 一个简介的钟表显示当前时间。 演示界面： ​ 转动时钟-演示地址 8.神秘游戏场景动画 一个3D模型，用户可放大缩小和旋转。 演示界面： ​ 神秘游戏场景动画-演示地址","categories":[{"name":"HTML","slug":"HTML","permalink":"https://yellowsy.github.io/categories/HTML/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"Linux命令","slug":"Linex命令","date":"2022-09-13T12:46:03.000Z","updated":"2022-09-18T06:59:34.720Z","comments":true,"path":"2022/09/13/Linex命令/","link":"","permalink":"https://yellowsy.github.io/2022/09/13/Linex%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1. 常用命令重启网卡12systemctl restart network service network restart 用户切换12su hsy（普通用户）su - (切换到root用户) 关机12345halt shutdown -h now (立即关机) shutdown -h +5(五分钟以后关机)shutdown -c (取消关机)init 0 (关机) ；init 6 (重启) 使用 “ ；”一次输入多个命令1command1 ; command2 ; command3 常用小技巧 显示或操作命令历史列表 1history 补全路径 文件或目录的首几个字母+Tab 显示上一条路径 Esc+. (点) 2. 操作文件和目录删除文件12345rm file 删除文件（可以不为空删除）rm -f flie 强制删除rm -r 目录名 递归删除目录（该目录下可以有其他文件，被一起删除）rmdir 删除空目录 创建目录1234mkdir--创建目录 mkdir dir1创建一个目录mkdir dir1 dir2 dir3 一次创建多个目录mkdir -p dir1/dir2 递归生成目录dir1和dir2,即dir1为当前目录的子目录，dir2为dir1的子目录 复制文件和目录123cp item1 item2 将文件或目录item1复制到item2cp -r 递归复制目录cp -p 保留源文件的属性不变 移动和重命名文件1mv item1 item2 将文件或目录item1移动或重命名为item2 创建硬链接和链接符号12345ln file link 创建硬链接 （就是为文件额外创建一个目录项）a.硬链接不能引用目录，只能引用文件b.硬链接不能跨物理设备ln -s item link 创建链接符号 （item可以是文件和目录）相当于用文本描述目标文件相对于符号链接的位置 3.初步探索Linux使用ls命令之乐123456. (一个点) 表示在当前目录ls 查看当前目录所包含的文件和子目录ls -l 将输出结果改成长格式ls -a 列出所有文件ls -d 显示目录本身的属性，而非其内部的文件列表 （只显示目录本身）ls -h 人性化显示容量信息，以K、M、G等单位表示文件大小。 使用file命令确定文件类型1file filename 使用less命令查看文本文件 键G 移动到文件末尾 键Q 退出less命令 通配符1234567* 匹配任意多个字符 ls -d /etc/*conf* 显示/etc目录下所有名字中包括“conf”的文件或目录。 ls -d /etc/pa* 列出/etc目录下所有以“pa”开头的文件或目录，j加上 -d 只显示目录本身,不显示其内容？ 匹配任意单个字符 ls -lh /dev/sa? 以长格式列出/dev目录中所有以“sd”开头并且文件名只有3个字符的文件信息。(sa给定，第三个字符任意(即？))通配符“[ ]”可以匹配指定范围内的任意单个字符。 ls /dev/[a-c]*列出/dev/目录中以“a”、“b”、“c”开头的所有文件。 时间戳 访问时间(access time:atime): 上一次文件访问时间； 内容修改时间(modified time:mtime): 上次文件内容修改时间； 元信息改变时间(change time:ctime): 上次文件属性改变时间； 1stat -[选项] [文件] 查看文件的元信息 4.和命令打交道识别命令1234显示命令类型 type command(要检查的文件名)显示可执行文件的位置 which command 获取命令文档123456789101112help--获取Shell内建命令的帮助信息 例如：help cd--help 显示用法信息 mkdir --helpman 显示命令的手册页 例如 man ls man section search_term ；section指明节号 man -k 根据关键字查找显示适合的命令清单（根据关键字查找） apropos partition(关键字)whatis --显示手册页的简述info--显示程序的info条目 使用alias创建自己的命令12alias name=&#x27;string&#x27; (name为自己所起的名字，string为命令)使用unalias命令可以删除别名 5.重定向标准输出重定向12345将ls -l /usr/bin 的输出结果保存在ls-output.txt中 ls - l/usr/bin &gt; ls-output.txt （ls的结果本来应该输出在屏幕上）将重定向的标准输出追加到文件尾，而不是将其从头覆盖 使用 &gt;&gt; : ls - l/usr/bin &gt;&gt; ls-output.txt&gt; 覆盖重定向 ； &gt;&gt; 追加重定向 标准错误重定向12标准错误重定向对应的描述符为2，以下将输出错误信息定向到 ls-error.txt例：ls -l /bin/usr 2&gt; ls-error.txt 标准输入重定向12345cat 将键盘输入的内容在屏幕上原样输出cat 命令读取一个或多个文件并将其复制到标准输出（显示文本文件内容）创建一个文件存放从键盘输入的字符 a.cat lazy_dog.txt （换行）The quick brown fox jumped over the lazy dog. b.查看lazy_dog .txt文件 例：cat lazy_dog.txt或者cat&lt;lazy_dog.txt 管道123456789101112131415161718192021管道符“|”用于连接左右两个命令，将“I”左边命令的执行结果作为“|”右边命令的输入 将标准输出的命令用less命令将其结果逐页显示出来 ls -l /usr/bin | less排序列表 ls /bin/usr/bin | sort | lessuniq--报告或忽略重复行 ls /bin/usr/bin | sort | uniq | lesswc 统计文件中换行符，单词以及直字节的数量 wc ls-error.txt (输出三个数字分别是：行数，单词数，字节数) wc -l 限制只输出文件行数grep 输出与模式匹配的行 grep pattren filename -i 使grep命令在搜索的时候忽略字母的大小写 -v 使grep命令只输出不匹配指定模式的行 -r 可以匹配关键字在当前目录下的子目录中查找 head/tall 输出文件的开头/结尾部分（默认十行） head -n 5 ls-output.txt (注意是文件) 运用在管道中：ls /usr/bin |tail -n 5 tail -f 持续观察文件，一旦文件中添加新行，立即显示在屏幕中，ctrl+c停止tee 读取标准输入并将输出结果写入标准输出的文件iddiff file1 file2 比较两个文件的不同；结果中的a,b,c分别代表添加，删除和修改;以&quot;&lt;&quot;开始的行属于文件1，以“&gt;”开始的行属于文件2。 6. Shell眼看世界123456789算术扩展(仅支持整数，不支持小数) echo $((expression)) echo $((2+2)) / : 除法 ，结果为整数 * : 求幂花括号扩展 echo Front-&#123;A,B,C&#125;-Back 结果：Front-A-Back Front-B-Back Front-C-Back echo &#123;01..15&#125; 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 7. 高级键盘技巧光表移动 Ctrl+A 将光标移动到首行 Ctrl+E 将光标移动到行尾 Ctrl+F 将光标v向前移动一个字符；等同于右方向键位 Ctrl+B 将光表向后移动一个字符；等同于左方向键位 Ctrl+L 清除屏幕，将光标移动到左上角。等同于clear命令 修改文本 Ctrl+D 删除光标处的字符 Ctrl+T 将光标出的字符与其之前的单词对调 剪切和粘贴文本 Ctrl+K 剪切从光标处到行尾的文本 Ctrl+U 剪切从光标处到行首的文本 Ctrl+Y 将kill-ring缓冲区内的文本粘贴到光标 搜索历史记录 Ctrl+P 移动到上一条搜索记录。等同于使用上方向建 Ctrl+N 移动到下一条搜索记录。等同于使用下方向建 Ctrl+R 反向增量搜索。从当前命令行开始向上增量搜索历史记录列表 Ctil+O 执行历史记录列表中的当前命令并移动到下一条命令。如果你想要重复执行历史列表中的一系列命令，该组合键非常方便 ！！ 重复上一条命令 ！number 重复命令历史记录列表中第number个命令 8. 文件访问权限文件权限修改 3种基本操作：读(r)， 写(w)， 执行(x)； 3类用户划分：文件拥有者(user)，文件所属组(group)，其他用户(other)； 文件访问权限可以使用命令chmod修改； chmod mode|octal-mode File… 按照mode或octal-mode描述的方式设置File的访问权限 mode: 字符形式描述的权限:[ugoa][-+&#x3D;][rwxXst] ugoa：u(拥有者)，g(所有组)，o(其他用户)，a(所有用户) stat命令查看文件元信息 文件类型 文件访问权限 -+&#x3D;：-(删除权限)，+(增加权限)，&#x3D;(重设权限) rwxXst：r(读)，w(写)，r(执行)，s(suid或sgid)，t(sticky bit) 12chmod a=rwx file 设置文件file的访问权限为所有用户可读/写/执行修改后file的文件权限为：-rwxrwxrwx . u=rwx g=rwx o=rwx octal-mode：八进制形式描述的权限：[-+&#x3D;][0-7]+ -+&#x3D;：-(删除权限)，+(增加权限)，&#x3D;(重设权限) [0-7]+：表示数0-7可重复多次，通常可以有4个 第1个八进制数表示特殊权限：4(suid)，2(sgid)，1(sticky bit) 第2个八进制数表示拥有者权限：4(r)，2(w)，1(x) 第3个八进制数表示所属组权限：4(r)，2(w)，1(x) 第4个八进制数表示其他用户权限：4(r)，2(w)，1(x) 文件默认权限umark掩码 显示或修改umask掩码(用于决定新建文件时如何赋予权限) umask掩码的默认值通常设置为002或022； 假设umask掩码值为022： 新建文件时：将文件权限设置为 666-022&#x3D;644，即rw-r–r–； 新建目录时：将目录权限设置为 777-022&#x3D;755，即rwxr-xr-x； umask 查看umask掩码值； umask nnn 临时修改umask掩码值为nnn(由3个八进制数组成)；","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yellowsy.github.io/categories/Linux/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"适合发朋友圈的文案","slug":"我的第一篇博客","date":"2022-09-12T12:19:21.000Z","updated":"2022-09-18T02:55:14.769Z","comments":true,"path":"2022/09/12/我的第一篇博客/","link":"","permalink":"https://yellowsy.github.io/2022/09/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1.梅花何止落满一整座南山 2.我已经懒得沟通了 你说夜里有太阳我都认爱哪里是神殿 分明是十里扬州、灯火不休你是落日弥漫的橘 天边透亮的星我与春风皆过客 你携秋水揽星河 3.梦里不觉人间晚 回首山河遍地秋空有一身热爱 却入不了这山海毕竟你是太阳 不是我一个人的光其实雨不大 是风搞得紧张 4.宫崎骏曾经说过 当陪你的那个人 要下车时 即使你在不舍 你也要心存感激 挥手告别 没个人的故事 开头都是极具温柔的 但往往故事的结尾都配不上整个开头 记住 没一个意难平的结果 都是我们最好的结局 5.爱意随风起 却不随风散 这路遥马急的人间 你在我心里何止好几年 6.“一定要文采斐然吗，我磕磕绊绊，叙意不清的语句也是爱一定要娓娓道来吗 我词不达意 语未由衷的叙述也是爱一定要妙语连珠吗 我支支吾吾 含糊其辞的言语也是爱啊。” 7.如果你喜欢冬天，那是因为有夏天的存在。那么人为什么要工作学习呢？是为了以后开心，如果你每天只是玩的话，那可能玩就不是一件特别开心的事。所以人要有束缚才会有自由，有痛苦才会有快乐。只有在忙碌的时候才能体会到闲暇的愉悦。光明也只有在黑暗中看到。","categories":[{"name":"文案","slug":"文案","permalink":"https://yellowsy.github.io/categories/%E6%96%87%E6%A1%88/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://yellowsy.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://yellowsy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"HTML","slug":"HTML","permalink":"https://yellowsy.github.io/categories/HTML/"},{"name":"Linux","slug":"Linux","permalink":"https://yellowsy.github.io/categories/Linux/"},{"name":"文案","slug":"文案","permalink":"https://yellowsy.github.io/categories/%E6%96%87%E6%A1%88/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yellowsy.github.io/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"https://yellowsy.github.io/tags/Java/"},{"name":"程序员","slug":"程序员","permalink":"https://yellowsy.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yellowsy.github.io/tags/Hexo/"},{"name":"生活","slug":"生活","permalink":"https://yellowsy.github.io/tags/%E7%94%9F%E6%B4%BB/"}]}